# All of this is for iodine.

files <- scan ("functions.txt",what="")
for (file in files) {
    cat(file, "\n")
    source(file)
}

library( splines )

x11( colortype = "mono" )
X11(colortype="pseudo.cube")

#
#
#   Ref Scenario
#
#

#uploading stochastically generated curves for concentration vs time
# each of these curves is generated by running an analytical solution with a randomly
# generated set of physical parameters from the GTMCHEM code

dose.ref <- matrix( scan( "ref-i-det.d" ), 1000, 111, 
  byrow = T )[ , 62:111 ]

time.ref <- matrix( scan( "ref-i-det.d" ), 1000, 111, 
  byrow = T ) [ ,12:61 ]

dose.ref[ dose.ref < 1e-12 ] <- NA

for ( i in 1:1000 ) {
  count <- 0
  
  for ( j in 1:50 ) {
     if ( is.na( dose.ref [ i,j ]) == FALSE ) {
       count <- count +1
     }
  }
  
  if ( count<3 ) {
    cat ("Curve ", i, " doesn't have enough values!")
  }
}


argvals.ref <- log( t( time.ref ) )

Y.ref <- log( t( dose.ref ) )

tmax.ref <- rep( 0, 1000 )

coef.ref <- matrix( 0, 1000, 4 )


# Finding maximum of each contaminant curve
for ( j in 1:1000 ) {

  ly <- Y.ref[ , j ]

  lt <- argvals.ref[ , j ]

  coef.ref[ j, ] <- lsfit( cbind( lt, lt^2, lt^3 ), ly )$coef

  tmax.ref[ j ] <- ( ( - coef.ref[ j, 3 ] ) - sqrt( coef.ref[ j, 3 ]^2 - 
    3 * coef.ref[ j, 2 ] * coef.ref[ j, 4 ] ) ) / ( 3 * coef.ref[ j, 4 ] )

  argvals.ref[ , j ] <- argvals.ref[ , j ] - tmax.ref[ j ]

}

ymax.ref <- coef.ref[ , 1 ] + coef.ref[ , 2 ] * tmax.ref + 
  coef.ref[ , 3 ] * tmax.ref^2 + coef.ref[ , 4 ] * tmax.ref^3

vertical.scale.ref <- matrix( 0, 50, 1000 )

for ( i in 1:50 ) {

  for ( j in 1:1000 ) {

    vertical.scale.ref[ i, j ] <- ymax.ref[ j ]

  }

}

#re-centering all contaminant profiles to all their maxima
Y.ref <- Y.ref - vertical.scale.ref



# For this scenario, everything above this line is included in the workspace

graphics.off()

postscript("cubic-fit-small.ref.ps")


par( ask = F, mfrow = c( 3, 2 ) )

#
# Cubic fitting of the data to find the maximum of the curve.

for ( i in 1:1000 ) {

  ly <- Y.ref[ , i ]

  lt <- argvals.ref[ , i ]

  yt.reg <- lsfit( cbind( lt, lt^2 ), ly )

  if (i<5)
  {
  plot( lt, ly, xlim = range( argvals.ref),
    ylim = range( Y.ref[ ! is.na( Y.ref ) ] ), xlab = "Time (yr)", ylab = "Dose (Sv/yr)" )

  lines( lt, cbind( 1, lt, lt^2 ) %*% yt.reg$coef, lty = 1 )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  plot( lt, yt.reg$residuals, xlab = "Time (yr)", ylab = "(Fitted - data value)^2")

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  abline( h = 0 )
  }
}


#
# Plotting all the curves
#

graphics.off()

postscript("all_reg-curves.ref.ps")

par( ask = F, mfrow = c( 1, 1 ) )

plot( argvals.ref[ , 1 ], Y.ref[ , 1 ], xlim = range( argvals.ref ),
    ylim = range( Y.ref[ ! is.na( Y.ref ) ] ), type = 'l', xlab = "log ( Time (yr) )", ylab = "log ( Dose (Sv/yr) )" )

for ( i in 2:1000 ) {

  lines( argvals.ref[ , i ], Y.ref[ , i ], lty = 1 )

}

#
#  Scatter plot of tmax vs. maximum dose
#

graphics.off()

postscript("tmax-maxdose.ref.ps")

par( cex=2.0 )
plot( tmax.ref, ymax.ref, xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )" )

cor( tmax.ref, ymax.ref )

# -0.6684716

######

# we decided not to do this. Here we use a polynomial basis to represent each contaminant curve

polybasis.ref <- create.polynomial.basis( range( argvals.ref ), 3 )

dosefd.poly.ref <- data2fd( Y.ref, argvals.ref, polybasis.ref )

par( ask = T )

for ( i in 1:100 ) {

   plot.fd( dosefd.poly.ref[ i ], ylim = c( log( 1e-12 ), 0 ) )

   points( argvals.ref[ , i ], Y.ref[ , i ], matplt = T )

}

plot.fd( dosefd.poly.ref, matplt = T, xlim = range( argvals.ref ), 
  ylim = c( log( 1e-12 ), 0 ), col = 1 )

plot.fd( dosefd.poly.ref, Lfd = 1, matplt = T, xlim = range( argvals.ref ), 
  ylim = c( log( 1e-12 ), - log( 1e-12 ) ), col = 1 )

######

# here we need to use a basis common to all scenarios with a 
# command of the form
#
#   splinebasis <- create.bspline.basis( *, 15 )
#
# where * is wide enough at both ends for ALL scenarios

#> range( argvals.fp )
#
#[1] -2.440091  1.507633
#
#> range( argvals.ref )
#
#[1] -2.516565  1.914673


sce.max <- ceiling ( max( range( argvals.ref[ ! is.na( argvals.ref ) ] ), range( argvals.fp[ ! is.na( argvals.fp ) ] ),
range( argvals.eic[ ! is.na( argvals.eic ) ] ), range( argvals.ga[ ! is.na( argvals.ga ) ] ),
range( argvals.hde[ ! is.na( argvals.hde ) ] ), range( argvals.ag[ ! is.na( argvals.ag ) ] ) ) )

sce.min <- floor ( min( range( argvals.ref[ ! is.na( argvals.ref ) ] ), range( argvals.fp[ ! is.na( argvals.fp ) ] ),
range( argvals.eic[ ! is.na( argvals.eic ) ] ), range( argvals.ga[ ! is.na( argvals.ga ) ] ),
range( argvals.hde[ ! is.na( argvals.hde ) ] ), range( argvals.ag[ ! is.na( argvals.ag ) ] ) ) )

library( splines )



# old 
splinebasis <- create.bspline.basis( c( sce.min, sce.max ), 6)

#splineBasis <- bsplineBasis (fDomain = c( sce.min, sce.max ), norder=6)

raw.dosefd.spline.ref <- data2fd( Y.ref, argvals.ref, splinebasis )

# old dosefd.spline.ref <- smooth.fd( dosefd.spline.ref, lambda = 1e-4 )
parclass.ref <- fdPar(raw.dosefd.spline.ref,2,lambda=10)

dosefd.spline.ref <- smooth.fd( raw.dosefd.spline.ref, parclass.ref )

# Plotting splines superimposed on data values


graphics.off()

postscript("splines.ref.ps")

par( ask = F, mfrow = c( 3, 3 ) )

for ( i in 1:9 ) {

   plot.fd( dosefd.spline.ref[ i ], ylim = c( log( 1e-12 ), 0 ), xlab = "Time (Yr)", ylab = "Dose (Sv/yr)" )

   points( argvals.ref[ , i ], Y.ref[ , i ], matplt = T )

}

square.diff <- matrix ( 0, 50, 1000 )

for ( i in 1:1000 ) {

   argvals.vector <- argvals.ref[ ,i ]

   fit.val <- eval.fd( argvals.vector, dosefd.spline.ref )

   for ( j in 1:50 ) {

     square.diff[ j, i ] <- ( fit.val[ j, i ] - Y.ref[ j, i ] )^2

   }

}

#
# Plots of squared discrepancies between the data curves and the spline curves
#

graphics.off()

postscript("splines-discrepancies.ref.ps")

par( ask = F, mfrow = c( 3, 2 ) )


for ( i in 1:3 ) {

   plot.fd( dosefd.spline.ref[ i ], ylim = c( log( 1e-12 ), 0 ), xlab = "log( Time (Yr) )", ylab = "log ( Dose (Sv/yr) )" )

   points( argvals.ref[ , i ], Y.ref[ , i ], matplt = T )

  plot( argvals.ref[ , i ], square.diff[ , i ], xlab = "log( Time (Yr) )", ylab = "(Fitted - data value)^2" )

}

graphics.off()

postscript("mean_sd.ref.ps")

par( ask = F, mfrow = c( 2, 1 ) )

plot( mean.fd( dosefd.spline.ref ), xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )" )

plot( std.fd( dosefd.spline.ref ), xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )" )

#
# FDA Principal Components Analysis
#
# Warning: Doesn't work with the default functions. We have to use a modified 
# version of pca.fd.ssc, which is located in David's home directory (under 
# Papers/Mendes)
#


pca.spline.ref <- pca.fd( dosefd.spline.ref, nharm = 3 )

#
# Plotting  harmonics
#

temp.pca.spline.ref <-  pca.spline.ref[[1]]

finetime <- seq(-3,2,length=100)

spline.fd.mat.ref <- eval.fd(temp.pca.spline.ref,finetime)


# Plot below doesn't work
 
par(mfrow=c(2,2))
for (i in 1:3) {
    plot(finetime, spline.fd.mat.ref[,i], type="l", xlim=c(-3,2),
    ylim = range( Y.ref[ ! is.na( Y.ref ) ] ), xlab="Years",
    ylab="Value of PC curve"))
    abline(h=0,lty=2)
}

# This seems to work

graphics.off()

postscript("pca123.ref.ps")

par( ask = F, mfrow = c( 3, 1 ) )

plot(finetime, spline.fd.mat.ref[,1], xlab = "log( Time (Yr) )", ylab = "Value of Principal Component Curve")

plot(finetime, spline.fd.mat.ref[,2], xlab = "log( Time (Yr) )", ylab = "Value of Principal Component Curve")

plot(finetime, spline.fd.mat.ref[,3], xlab = "log( Time (Yr) )", ylab = "Value of Principal Component Curve")

#
# Plotting slightly perturbed values to improve visualization
#
graphics.off()

postscript("pca-perturbed-mean123.ref.ps")

par( ask = F, mfrow = c( 3, 1 ) )

plot.pca.fd( pca.spline.ref, harm=1, xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )" )

plot.pca.fd( pca.spline.ref, harm=2, xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )" )

plot.pca.fd( pca.spline.ref, harm=3, xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )" )

#
# Plotting the eigenvalues.
#

harm.eigval.ref <- pca.spline.ref$values

graphics.off()

postscript("pca-eigenvalues.ref.ps")

plot (1:14,log10(harm.eigval.ref[1:14]),type='b',xlab='Eigenvalue Number',
ylab='Log10 Eigenvalue')

abline ( lsfit(4:14,log10(harm.eigval.ref[4:14])),lty=2 )

#
# Plotting the scores
#
graphics.off()

postscript("pca-scores.ref.ps")

harm.scores.ref <- pca.spline.ref[[3]]

par ( mfrow=c(1,1),pty="s" )

# Indexed by run number



plot( harm.scores.ref [,1], harm.scores.ref [,2], type="n", xlab="Harm. I",
 ylab = "Harm. 2")

text ( harm.scores.ref [,1], harm.scores.ref [,2] )

# Not indexed at all


plot( harm.scores.ref [,1], harm.scores.ref [,2],xlab="Harmonic I",
 ylab = "Harmonic 2")



# pca separately with each scenario rather than combined is 
# more informative

graphics.off( )

#
# FDA Linear Modelling
#


# Reading model's input values.

# Each row of 'tinputs.ref' will contain the inputs values for the i-th run

tinputs.ref <- matrix( scan( "ref-i-det.d" ), 1000, 111, byrow = TRUE )[ , 2:10]
  
# Mean and S.D. of each input parameter

mean (tinputs.ref[,1])

sqrt(var(tinputs.ref[,1]))

mean (tinputs.ref[,2])

sqrt(var(tinputs.ref[,2]))

mean (tinputs.ref[,3])

sqrt(var(tinputs.ref[,3]))

mean (tinputs.ref[,4])

sqrt(var(tinputs.ref[,4]))

mean (tinputs.ref[,5])

sqrt(var(tinputs.ref[,5]))

mean (tinputs.ref[,6])

sqrt(var(tinputs.ref[,6]))

mean (tinputs.ref[,7])

sqrt(var(tinputs.ref[,7]))

mean (tinputs.ref[,8])

sqrt(var(tinputs.ref[,8]))

mean (tinputs.ref[,9])

sqrt(var(tinputs.ref[,9]))

# Backtransforming the log values

tinputs.ref[,2] <- log( tinputs.ref[,2] )
tinputs.ref[,3] <- log( tinputs.ref[,3] )
tinputs.ref[,6] <- log( tinputs.ref[,6] )
tinputs.ref[,9] <- log( tinputs.ref[,9] )


# Standardizing the input parameters
# Leads to pathological results
#for (i in 1:9)
#{
#   tinputs.ref[,i] <- (tinputs.ref[,i] - mean (tinputs.ref[,i]))/ sqrt(var(tinputs.ref[,i]))
#}

# Obsolete
#xfd.ref <- cbind( rep( 1, 1000 ), tinputs.ref)
# Obsolete
#coef.ref <- getcoef( dosefd.spline.ref )

# Standardizing the dose curves
#Leads to pathological results
#for (i in 1:15)
#{
#   coef.ref[i,] <- (coef.ref[i,] - mean (coef.ref[i,]))/ sqrt(var(coef.ref[i,]))
#}

# Obsolete
# fd.ref <- create.fd( coef.ref, splinebasis )

#2006 reg.ref <- linmod.fd( tinputs.ref, dosefd.spline.ref,ylambda=10 )

#2006 beta.ref <- reg.ref$reg

constantbasis <- create.constant.basis( c( sce.min, sce.max ))

input1.ref <- matrix(NA,50,1000)
input2.ref <- matrix(NA,50,1000)
input3.ref <- matrix(NA,50,1000)
input4.ref <- matrix(NA,50,1000)
input5.ref <- matrix(NA,50,1000)
input6.ref <- matrix(NA,50,1000)
input7.ref <- matrix(NA,50,1000)
input8.ref <- matrix(NA,50,1000)
input9.ref <- matrix(NA,50,1000)

for (j in 1:1000){
     input1.ref[,j] <- rep(tinputs.ref[j,1],50)   
     input2.ref[,j] <- rep(tinputs.ref[j,2],50)   
     input3.ref[,j] <- rep(tinputs.ref[j,3],50)   
     input4.ref[,j] <- rep(tinputs.ref[j,4],50)   
     input5.ref[,j] <- rep(tinputs.ref[j,5],50)   
     input6.ref[,j] <- rep(tinputs.ref[j,6],50)   
     input7.ref[,j] <- rep(tinputs.ref[j,7],50)   
     input8.ref[,j] <- rep(tinputs.ref[j,8],50)   
     input9.ref[,j] <- rep(tinputs.ref[j,9],50)   
}

> input1.const.ref <- data2fd( input1.ref, argvals.ref, constantbasis )
> input2.const.ref <- data2fd( input2.ref, argvals.ref, constantbasis )
> input3.const.ref <- data2fd( input3.ref, argvals.ref, constantbasis )
> input4.const.ref <- data2fd( input4.ref, argvals.ref, constantbasis )
> input5.const.ref <- data2fd( input5.ref, argvals.ref, constantbasis )
> input6.const.ref <- data2fd( input6.ref, argvals.ref, constantbasis )
> input7.const.ref <- data2fd( input7.ref, argvals.ref, constantbasis )
> input8.const.ref <- data2fd( input8.ref, argvals.ref, constantbasis )
> input9.const.ref <- data2fd( input9.ref, argvals.ref, constantbasis )

input.list <- list(input1.const.ref,input2.const.ref,input3.const.ref,input4.const.ref,input5.const.ref,input6.const.ref,input7.const.ref,input8.const.ref,input9.const.ref)

beta1 <- matrix(1,50,1000)
beta1.ref <- data2fd( beta1, argvals.ref, constantbasis )
beta2 <- matrix(1,50,1000)
beta2.ref <- data2fd( beta2, argvals.ref, constantbasis )
beta3 <- matrix(1,50,1000)
beta3.ref <- data2fd( beta3, argvals.ref, constantbasis )
beta4 <- matrix(1,50,1000)
beta4.ref <- data2fd( beta4, argvals.ref, constantbasis )
beta5 <- matrix(1,50,1000)
beta5.ref <- data2fd( beta5, argvals.ref, constantbasis )
beta6 <- matrix(1,50,1000)
beta6.ref <- data2fd( beta6, argvals.ref, constantbasis )
beta7 <- matrix(1,50,1000)
beta7.ref <- data2fd( beta7, argvals.ref, constantbasis )
beta8 <- matrix(1,50,1000)
beta8.ref <- data2fd( beta8, argvals.ref, constantbasis )
beta9 <- matrix(1,50,1000)
beta9.ref <- data2fd( beta9, argvals.ref, constantbasis )

beta.list <- list(beta1,beta2,beta3,beta4,beta5,beta6,beta7,beta8,beta9)

# or

betafd.list <- list(beta1.ref,beta2.ref,beta3.ref,beta4.ref,beta5.ref,beta6.ref,beta7.ref,beta8.ref,beta9.ref)

fRegress(dosefd.spline.ref,input.list,betafd.list)

#input1.const.ref <- data2fd( input1.ref, argvals.ref, constantbasis )
#inputs.const.ref <- data2fd( tinputs.ref, argvals.ref, constantbasis )

fRegress (Y.ref,

graphics.off()

postscript("linreg-beta1.ref.ps")

#par(cex=2.5)


plot( beta.ref[1], 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )')

graphics.off()

postscript("linreg-beta2.ref.ps")

plot( beta.ref[2],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta3.ref.ps")

plot( beta.ref[3],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta4.ref.ps")

plot( beta.ref[4],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta5.ref.ps")

plot( beta.ref[5],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta6.ref.ps")

plot( beta.ref[6],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta7.ref.ps")

plot( beta.ref[7],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta8.ref.ps")

plot( beta.ref[8],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta9.ref.ps")

plot( beta.ref[9],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-allbetas.ref.ps")

plot( beta.ref, ylim = c( -0.6, 0.3 ), 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

yhat.ref <- reg.ref$yhat

plot( yhat.ref, ylim = c( log( 1e-12 ), 0 ) )


#Figures for MPhil thesis

graphics.off()

postscript("linreg-beta1234.ref.ps")

par(title="Reference Scenario",mfrow = c( 2, 2 ))

plot( beta.ref[1],xlab ='log( time )', 
ylab = 'log( dose )',main="Containment time")

plot( beta.ref[2],xlab ='log( time )', 
ylab = 'log( dose )',main="Leaching rate")

plot( beta.ref[3],xlab ='log( time )', 
ylab = 'log( dose )',main="Water velocity, Layer 1")

plot( beta.ref[4],xlab ='log( time )', 
ylab = 'log( dose )',main="Layer 1 length")

graphics.off()

postscript("linreg-beta5678.ref.ps")

par(title="Reference Scenario",mfrow = c( 3, 2 ))

plot( beta.ref[5],xlab ='log( time )', 
ylab = 'log( dose )',main="Retention in layer 1")

plot( beta.ref[6],xlab ='log( time )', 
ylab = 'log( dose )',main="Water velocity in layer 2")

plot( beta.ref[7],xlab ='log( time )', 
ylab = 'log( dose )',main="Layer 2 length")

plot( beta.ref[8],xlab ='log( time )', 
ylab = 'log( dose )',main="Retention in layer 2")

plot( beta.ref[9],xlab ='log( time )', 
ylab = 'log( dose )',main="Water flow rate")

graphics.off()




#
# Calculating R^2
#

sse <-  (fd.ref - )^2










# Calculations for flux

dose.ref <- matrix( scan( "ref-i-det.d" ), 1000, 111, 
  byrow = T )[ , 62:111 ]

tinputs.ref <- matrix( scan( "ref-i-det.d" ), 1000, 111, 
  byrow = t )[ , 2:10]

dose.ref[ dose.ref < 1e-12 ] <- NA

flux.ref <- dose.ref * tinputs.ref[,9] / (56*0.73)

for ( i in 1:1000 ) {
  count <- 0
  
  for ( j in 1:50 ) {
     if ( is.na( flux.ref [ i,j ]) == FALSE ) {
       count <- count +1
     }
  }
  
  if ( count<3 ) {
    cat ("Curve ", i, " doesn't have enough values!")
  }
}


Yf.ref <- log( t( flux.ref ) )

tmax.ref <- rep( 0, 1000 )

coef.ref <- matrix( 0, 1000, 4 )

for ( j in 1:1000 ) {

  ly <- Yf.ref[ , j ]

  lt <- argvals.ref[ , j ]

  coef.ref[ j, ] <- lsfit( cbind( lt, lt^2, lt^3 ), ly )$coef

  tmax.ref[ j ] <- ( ( - coef.ref[ j, 3 ] ) - sqrt( coef.ref[ j, 3 ]^2 - 
    3 * coef.ref[ j, 2 ] * coef.ref[ j, 4 ] ) ) / ( 3 * coef.ref[ j, 4 ] )

  argvals.ref[ , j ] <- argvals.ref[ , j ] - tmax.ref[ j ]

}

ymax.ref <- coef.ref[ , 1 ] + coef.ref[ , 2 ] * tmax.ref + 
  coef.ref[ , 3 ] * tmax.ref^2 + coef.ref[ , 4 ] * tmax.ref^3

vertical.scale.ref <- matrix( 0, 50, 1000 )

for ( i in 1:50 ) {

  for ( j in 1:1000 ) {

    vertical.scale.ref[ i, j ] <- ymax.ref[ j ]

  }

}

Yf.ref <- Yf.ref - vertical.scale.ref

for ( i in 1:1000 ) {

  ly <- Yf.ref[ , i ]

  lt <- argvals.ref[ , i ]

  yt.reg <- lsfit( cbind( lt, lt^2 ), ly )

  plot( lt, ly, xlim = range( argvals.ref ),
    ylim = range( Yf.ref[ ! is.na( Yf.ref ) ] ) )

  lines( lt, cbind( 1, lt, lt^2 ) %*% yt.reg$coef, lty = 1 )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  plot( lt, yt.reg$residuals )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  abline( h = 0 )

}

#
#  Scatter plot of tmax vs. maximum dose
#


plot( tmax.ref, ymax.ref )

cor( tmax.ref, ymax.ref )


#
# Setting up the fd object.
#

fluxfd.spline.ref <- data2fd( Yf.ref, argvals.ref, splinebasis )

fluxfd.spline.ref <- smooth.fd( fluxfd.spline.ref, lambda = 1e-4 )

# Various plots.

par( ask = T )

for ( i in 1:1000 ) {

   plot.fd( fluxfd.spline.ref[ i ], ylim = c( log( 1e-12 ), 0 ) )

   points( argvals.ref[ , i ], Yf.ref[ , i ], matplt = T )

}

square.diff <- matrix ( 0, 50, 1000 )

for ( i in 1:1000 ) {

   argvals.vector <- argvals.ref[ ,i ]

   fit.val <- eval.fd( argvals.vector, fluxfd.spline.ref )

   for ( j in 1:50 ) {

     square.diff[ j, i ] <- ( fit.val[ j, i ] - Yf.ref[ j, i ] )^2

   }

}

#
# Plots of squared discrepancies between the data curves and the spline curves
#


par( ask = F, mfrow = c( 4, 2 ) )


for ( i in 1:1000 ) {

  plot( argvals.ref[ , i ], square.diff[ , i ] )

}

plot( mean.fd( fluxfd.spline.ref ) )

plot( std.fd( fluxfd.spline.ref ) )

#
# Principal Components Analysis
#
# Warning: Doesn't work with the default functions. We have to use a modified 
# version of pca.fd.ssc, which is located in David's home directory (under 
# Papers/Mendes)
#


pca.spline.ref <- pca.fd( fluxfd.spline.ref, nharm = 3 )

#
# Plotting  harmonics
#

temp.pca.spline.ref <-  pca.spline.ref[[1]]

finetime <- seq(-3,2,length=100)

spline.fd.mat.ref <- eval.fd(temp.pca.spline.ref,finetime)

plot(finetime, spline.fd.mat.ref[,1])
plot(finetime, spline.fd.mat.ref[,2])
plot(finetime, spline.fd.mat.ref[,3])

#
# Plotting perturbed values
#

plot.pca.fd( pca.spline.ref )

#
# Plotting the eigenvalues.
#

harm.eigval.ref <- pca.spline.ref$values

plot (1:14,log10(harm.eigval.ref[1:14]),type='b',xlab='Eigenvalue Number',
ylab='Log10 Eigenvalue')

abline ( lsfit(4:14,log10(harm.eigval.ref[4:14])),lty=2 )

#
# Plotting the scores
#

harm.scores.ref <- pca.spline.ref[[3]]

par ( mfrow=c(1,1),pty="s" )

# Indexed by run number

plot( harm.scores.ref [,1], harm.scores.ref [,2], type="n", xlab="Harm. I",
 ylab = "Harm. 2")

text ( harm.scores.ref [,1], harm.scores.ref [,2] )

# Not indexed at all


plot( harm.scores.ref [,1], harm.scores.ref [,2],xlab="Harm. I",
 ylab = "Harm. 2")

#
# Linear Modelling
#


# Reading model's input values.

# Each row of 'tinputs.ref' will contain the inputs values for the i-th run

tinputs.ref <- matrix( scan( "ref-i.d" ), 1000, 111, 
  byrow = t )[ , 2:9]
  
# Mean and S.D. of each input parameter

mean (tinputs.ref[,1])

sqrt(var(tinputs.ref[,1]))

mean (tinputs.ref[,2])

sqrt(var(tinputs.ref[,2]))

mean (tinputs.ref[,3])

sqrt(var(tinputs.ref[,3]))

mean (tinputs.ref[,4])

sqrt(var(tinputs.ref[,4]))

mean (tinputs.ref[,5])

sqrt(var(tinputs.ref[,5]))

mean (tinputs.ref[,6])

sqrt(var(tinputs.ref[,6]))

mean (tinputs.ref[,7])

sqrt(var(tinputs.ref[,7]))

mean (tinputs.ref[,8])

sqrt(var(tinputs.ref[,8]))

mean (tinputs.ref[,9])

sqrt(var(tinputs.ref[,9]))

# Backtransforming the log values

tinputs.ref[,2] <- log( tinputs.ref[,2] )
tinputs.ref[,3] <- log( tinputs.ref[,3] )
tinputs.ref[,6] <- log( tinputs.ref[,6] )

# Standardizing the dose curves

for (i in 1:15)
{
   coef.ref[i,] <- (coef.ref[i,] - mean (coef.ref[i,]))/ sqrt(var(coef.ref[i,]))
}

fd.ref <- create.fd( coef.ref, splinebasis )

reg.ref <- linmod.fd( tinputs.ref, fd.ref )

beta.ref <- reg.ref$reg

plot( beta.ref[1], 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.ref[2],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.ref[3],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.ref[4],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.ref[5],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.ref[6],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.ref[7],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.ref[8],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.ref[9],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )
# ,xlim = c( -1, 1.2),
plot( beta.ref, ylim = c( -0.6, 0.3 ),
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

text( -2.9, 0.18, "RLEACH" )

text( -2.9, 0.14, "RET1" )

text( -2.9, 0.08, "STREAM" )

text( -2.9, 0.02, "VREAL2" )

text( -2.9, -0.03, "RET2" )

text( -2.9, -0.08, "CONTIM" )

text( -2.9, -0.34, "XPATH2" )

text( -2.9, -0.42, "VREAL1" )

text( -2.9, -0.51, "XPATH2" )


text( 1.9, -0.03, "RLEACH" )

text( 1.9, 0.17, "RET1" )

text( 1.9, 0.08, "STREAM" )

text( 1.3, 0.2, "VREAL2" )

text( 1.9, -0.11, "RET2" )

text( 1.9, 0.03, "CONTIM" )

text( 1.9, -0.25, "XPATH2" )

text( 1.9, -0.6, "VREAL1" )

text( 1.9, -0.51, "XPATH2" )



yhat.ref <- reg.ref$yhat

plot( yhat.ref, ylim = c( -1, 2 ) )
























#
#
#  FP scenario
#
#


dose.fp <- matrix( scan( "fp-i.d" ), 1000, 110, byrow = T )[ , 61:110 ]

time.fp <- matrix( scan( "fp-i.d" ), 1000, 110, byrow = T )[ , 11:60 ]

dose.fp[ dose.fp < 1e-12 ] <- NA

for ( i in 1:1000 ) {
  count <- 0
  
  for ( j in 1:50 ) {
     if ( is.na( dose.fp [ i,j ]) == FALSE ) {
       count <- count +1
     }
  }
  
  if ( count<3 ) {
    cat ("Curve ", i, " doesn't have enough values!")
  }
}


argvals.fp <- log( t( time.fp ) )

Y.fp <- log( t( dose.fp ) )

tmax.fp <- rep( 0, 1000 )

coef.fp <- matrix( 0, 1000, 4 )

for ( j in 1:1000 ) {

  ly <- Y.fp[ , j ]

  lt <- argvals.fp[ , j ]

  coef.fp[ j, ] <- lsfit( cbind( lt, lt^2, lt^3 ), ly )$coef

  tmax.fp[ j ] <- ( ( - coef.fp[ j, 3 ] ) - sqrt( coef.fp[ j, 3 ]^2 - 
    3 * coef.fp[ j, 2 ] * coef.fp[ j, 4 ] ) ) / ( 3 * coef.fp[ j, 4 ] )

  argvals.fp[ , j ] <- argvals.fp[ , j ] - tmax.fp[ j ]

}

ymax.fp <- coef.fp[ , 1 ] + coef.fp[ , 2 ] * tmax.fp + 
  coef.fp[ , 3 ] * tmax.fp^2 + coef.fp[ , 4 ] * tmax.fp^3

vertical.scale.fp <- matrix( 0, 50, 1000 )

for ( i in 1:50 ) {

  for ( j in 1:1000 ) {

    vertical.scale.fp[ i, j ] <- ymax.fp[ j ]

  }

}

Y.fp <- Y.fp - vertical.scale.fp


# For this scenario, everything above this line is included in the workspace

graphics.off()

postscript("cubic-fit-small.fp.ps")


par( ask = F, mfrow = c( 3, 2 ) )

#
# Cubic fitting of the data to find the maximum of the curve.
#


for ( i in 1:1000 ) {

  ly <- Y.fp[ , i ]

  lt <- argvals.fp[ , i ]

  yt.reg <- lsfit( cbind( lt, lt^2 ), ly )
  if (i<4)
  {
  plot( lt, ly, xlim = range( argvals.fp ),
    ylim = range( Y.fp[ ! is.na( Y.fp ) ] ), xlab = "log( Time (Yr) )", ylab = "log(  Dose (Sv/yr) )" )

  lines( lt, cbind( 1, lt, lt^2 ) %*% yt.reg$coef, lty = 1 )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  plot( lt, yt.reg$residuals, xlab = "log( Time (yr) )", ylab = "(Fitted - data value)^2" )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  abline( h = 0 )
  }

}

# Don't know what this routine plots.

par( ask = T, mfrow = c( 1, 1 ) )

for ( i in 1:1000 ) {

  plot( argvals.fp[ , i ], Y.fp[ , i ], xlim = range( argvals.fp ),
    ylim = range( Y.fp[ ! is.na( Y.fp ) ] ) )

}

par( ask = F )

#
# Plotting all the curves
#

graphics.off()

postscript("all_reg-curves.fp.ps")

par( ask = F, mfrow = c( 1, 1 ) )

plot( argvals.fp[ , 1 ], Y.fp[ , 1 ], xlim = range( argvals.fp ),
    ylim = range( Y.fp[ ! is.na( Y.fp ) ] ), type = 'l', xlab = "log( Time (yr) )", ylab = "log( Dose (Sv/yr) )" )


for ( i in 1:1000 ) {

  lines( argvals.fp[ , i ], Y.fp[ , i ], lty = 1 )

}

#
#  Scatter plot of tmax vs. maximum dose
#

graphics.off()

postscript("tmax-maxdose.fp.ps")

plot( tmax.fp, ymax.fp, xlab = "log( Time (yr) )", ylab = "log( Dose (Sv/yr) )" )

cor( tmax.fp, ymax.fp )

# -0.4344218

##############

# we decided not to do this

polybasis.fp <- create.polynomial.basis( range( argvals.fp ), 3 )

dosefd.poly.fp <- data2fd( Y.fp, argvals.fp, polybasis.fp )

plot.fd( dosefd.poly.fp, matplt = T, xlim = range( argvals.fp ), 
  ylim = c( log( 1e-12 ), 0 ), col = 1 )

plot.fd( dosefd.poly.fp, matplt = F, xlim = range( argvals.fp ), 
  ylim = c( log( 1e-12 ), 0 ), col = 1 )

plot.fd( dosefd.poly.fp, Lfd = 1, matplt = T, xlim = range( argvals.fp ), 
  ylim = c( log( 1e-12 ), - log( 1e-12 ) ), col = 1 )

##############

# using splines as basis instead
#
# Spline basis defined on the block dedicated top the Reference scenario

dosefd.spline.fp <- data2fd( Y.fp, argvals.fp, splinebasis )

dosefd.spline.fp <- smooth.fd( dosefd.spline.fp, lambda = 1e-4 )

par( ask = T )

#
# Plots of the spline fits superimposed on the data.
# 

graphics.off()

postscript("splines.fp.ps")


for ( i in 1:100 ) {

   plot.fd( dosefd.spline.fp[ i ], ylim = c( log( 1e-12 ), 0 ), xlab = "log( Time (yr) )", ylab = "log( Dose (Sv/yr) )" )

   points ( argvals.fp[ , i ], Y.fp[ ,i ], matplt = T )

}

square.diff <- matrix ( 0, 50, 1000 )

for ( i in 1:1000 ) {

   argvals.vector <- argvals.fp[ ,i ]

   fit.val <- eval.fd( argvals.vector, dosefd.spline.fp )

   for ( j in 1:50 ) {

     square.diff[ j,i ] <- ( fit.val[ j,i ] - Y.fp[ j, i ] )^2

   }

}

#
# Plots of squared discrepancies between the data curves and the spline curves
#

graphics.off()

postscript("splines-discrepancies.fp.ps")

par( ask = F, mfrow = c( 3, 2 ) )

for ( i in 1:3 ) {

   plot.fd( dosefd.spline.fp[ i ], ylim = c( log( 1e-12 ), 0 ), xlab = "log( Time (yr) )", ylab = "log( Dose (Sv/yr) )" )

   points ( argvals.fp[ , i ], Y.fp[ ,i ], matplt = T )

  plot( argvals.fp[ ,i ], square.diff[ ,i ], xlab = "log( Time (yr) )", ylab = "(Fitted - data value)^2" )

}

graphics.off()

postscript("mean-sd.fp.ps")

par( mfrow = c( 2, 1 ) )

plot( mean.fd( dosefd.spline.fp ), xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )" )

plot( std.fd( dosefd.spline.fp ), xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )" )

graphics.off()

postscript("sd.fp.ps")

plot( std.fd( dosefd.spline.fp ), xlab = "Time (Yr)", ylab = "Dose (Sv/yr)" )

#
# Principal Components Analysis
#
# Warning: Doesn't work with the default functions. We have to use a modified 
# version of pca.fd.ssc, which is located in David's home directory (under 
# Papers/Mendes)
#


pca.spline.fp <- pca.fd( dosefd.spline.fp, nharm = 3 )


#
# Plotting harmonics
#

temp.pca.spline.fp <-  pca.spline.fp[[1]]

finetime <- seq(-3,2,length=100)

spline.fd.mat.fp <- eval.fd(temp.pca.spline.fp,finetime)

graphics.off()

postscript("pca123.fp.ps")

par( mfrow = c( 3, 1 ) )

plot(finetime, spline.fd.mat.fp[,1], xlab = "log( Time (Yr) )", ylab = "Value of Principal Component Curve")

plot(finetime, spline.fd.mat.fp[,2], xlab = "log( Time (Yr) )", ylab = "Value of Principal Component Curve")

plot(finetime, spline.fd.mat.fp[,3], xlab = "log( Time (Yr) )", ylab = "Value of Principal Component Curve")


#
# Plotting the perturbed mean.
#
X11(colortype="pseudo.cube")

graphics.off()

postscript("pca-perturbed-mean123.fp.ps")

par( ask =F, mfrow = c( 3, 1 ) )

plot.pca.fd( pca.spline.fp, harm=1, xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )")

plot.pca.fd( pca.spline.fp, harm=2, xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )")

plot.pca.fd( pca.spline.fp, harm=3, xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )")

#
# Plotting the eigenvalues.
#

harm.eigval.fp <- pca.spline.fp$values

graphics.off()

postscript("pca-eigenvalues.fp.ps")

plot (1:14,log10(harm.eigval.fp[1:14]),type='b',xlab='Eigenvalue Number',ylab='Log10 Eigenvalue')

abline ( lsfit(4:14,log10(harm.eigval.fp[4:14])),lty=2 )

#
# Plotting the scores
#

graphics.off()

postscript("pca-scores.fp.ps")

harm.scores.fp <- pca.spline.fp[[3]]

par ( mfrow=c(1,1),pty="s" )

# Indexed by run number


plot( harm.scores.fp [,1], harm.scores.fp [,2], type="n", xlab="Harm. I", ylab = "Harm. 2")

text ( harm.scores.fp [,1], harm.scores.fp [,2] )

# Not indexed at all


plot( harm.scores.fp [,1], harm.scores.fp [,2],xlab="Harm. I",
 ylab = "Harm. 2")



###########

coef.ref <- getcoef( dosefd.spline.ref )

coef.fp <- getcoef( dosefd.spline.fp )

coef.merge <- cbind( coef.ref, coef.fp )

mergefd <- create.fd( coef.merge, splinebasis )

pca.spline <- pca.fd( mergefd, nharm = 3 )

plot.pca.fd( pca.spline )

# the separate PCAs give a better story than the merged PCA

###########

xfd <- cbind( rep( 1, 2000 ), c( rep( 0, 1000 ), rep( 1, 1000 ) ) )

linmod.str <- linmod.fd( xfd, mergefd )

intercept <- linmod.str$alpha

plot( intercept )

# a silly picture

regfd <- linmod.str$reg

plot( regfd, ylim = c( log( 1e-12 ), 0 ) )

yhatfd <- linmod.str$yhat

plot( yhatfd, ylim = c( log( 1e-12 ), 0 ) )

# R^2 function, F function: see book

#######

# with all six scenarios:

xfd <- cbind( rep( 1, 6000 ), c( rep( 1, 1000 ), rep( 0, 5000 ) ),
  c( rep( 0, 1000 ), rep( 1, 1000 ), rep( 0, 4000 ) ),
  c( rep( 0, 2000 ), rep( 1, 1000 ), rep( 0, 3000 ) ),
  c( rep( 0, 3000 ), rep( 1, 1000 ), rep( 0, 2000 ) ),
  c( rep( 0, 4000 ), rep( 1, 1000 ), rep( 0, 1000 ) ) )

#######

adding the inverse of the registration process back in?


#
# Linear Modelling
#


# Reading model's input values.

# for UNIX
tinputs.fp <- matrix( scan( "fp-i.d" ), 1000, 110, 
  byrow = t )[ , 2:10]

# for Windows
tinputs.fp <- matrix( scan( "c:\fp-i.d" ), 1000, 110, 
  byrow = t )[ , 2:10]
 
# Mean and S.D. of each input parameter

mean (tinputs.fp[,1])

sqrt(var(tinputs.fp[,1]))

mean (tinputs.fp[,2])

sqrt(var(tinputs.fp[,2]))

mean (tinputs.fp[,3])

sqrt(var(tinputs.fp[,3]))

mean (tinputs.fp[,4])

sqrt(var(tinputs.fp[,4]))

mean (tinputs.fp[,5])

sqrt(var(tinputs.fp[,5]))

mean (tinputs.fp[,6])

sqrt(var(tinputs.fp[,6]))

mean (tinputs.fp[,7])

sqrt(var(tinputs.fp[,7]))

mean (tinputs.fp[,8])

sqrt(var(tinputs.fp[,8]))


# Backtransforming the log values

tinputs.fp[,2] <- log( tinputs.fp[,2] )
tinputs.fp[,3] <- log( tinputs.fp[,3] )
tinputs.fp[,6] <- log( tinputs.fp[,6] )


# Standardizing the input parameters
# Leads to pathological results
#for (i in 1:8)
#{
#   tinputs.fp[,i] <- (tinputs.fp[,i] - mean (tinputs.fp[,i]))/ sqrt(var(tinputs.fp[,i]))
#}

xfd.fp <- cbind( rep( 1, 1000 ), tinputs.fp)

coef.fp <- getcoef( dosefd.spline.fp )

# Standardizing the dose curves
# Leads to pathological results
#for (i in 1:15)
#{
#   coef.fp[i,] <- (coef.fp[i,] - mean (coef.fp[i,]))/ sqrt(var(coef.fp[i,]))
#}


reg.fp <- linmod.fd( tinputs.fp, dosefd.spline.fp )

beta.fp <- reg.fp$reg

graphics.off()

postscript("linreg-beta1.fp.ps")

plot( beta.fp[1], 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta2.fp.ps")

plot( beta.fp[2],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta3.fp.ps")

plot( beta.fp[3],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta4.fp.ps")

plot( beta.fp[4],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta5.fp.ps")

plot( beta.fp[5],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta6.fp.ps")

plot( beta.fp[6],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta7.fp.ps")

plot( beta.fp[7],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta8.fp.ps")

plot( beta.fp[8],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-allbetas.fp.ps")

plot( beta.fp, ylim = c( -0.5, 0.5 ), 
  xlab = 'log( time )', ylab = 'log( dose )' )



yhat.fp <- reg.fp$yhat

plot( yhat.fp, ylim = c( log( 1e-12 ), 0 ) )







#Figures for MPhil thesis

graphics.off()

postscript("linreg-beta1234.fp.ps")

par(title="Reference Scenario",mfrow = c( 2, 2 ))

plot( beta.fp[1],xlab ='log( time )', 
ylab = 'log( dose )',main="Containment time")

plot( beta.fp[2],xlab ='log( time )', 
ylab = 'log( dose )',main="Leaching rate")

plot( beta.fp[3],xlab ='log( time )', 
ylab = 'log( dose )',main="Water velocity, Layer 1")

plot( beta.fp[4],xlab ='log( time )', 
ylab = 'log( dose )',main="Layer 1 length")

graphics.off()

postscript("linreg-beta5678.fp.ps")

par(title="Reference Scenario",mfrow = c( 2, 2 ))

plot( beta.fp[5],xlab ='log( time )', 
ylab = 'log( dose )',main="Retention in layer 1")

plot( beta.fp[6],xlab ='log( time )', 
ylab = 'log( dose )',main="Stream flow rate")

plot( beta.fp[7],xlab ='log( time )', 
ylab = 'log( dose )',main="Slow reversible adsorption rate, forward reaction")

plot( beta.fp[8],xlab ='log( time )', 
ylab = 'log( dose )',main="Slow reversible adsorption rate, backward reaction")

graphics.off()
















# Calculations for flux

dose.fp <- matrix( scan( "fp-i.d" ), 1000, 110, byrow = T )[ , 61:110 ]

time.fp <- matrix( scan( "fp-i.d" ), 1000, 110, byrow = T )[ , 11:60 ]

dose.fp[ dose.fp < 1e-12 ] <- NA

flux.fp <- dose.fp * tinputs.fp[,6] / (2800*0.73)

for ( i in 1:1000 ) {
  count <- 0
  
  for ( j in 1:50 ) {
     if ( is.na( flux.fp [ i,j ]) == FALSE ) {
       count <- count +1
     }
  }
  
  if ( count<3 ) {
    cat ("Curve ", i, " doesn't have enough values!")
  }
}


Yf.fp <- log( t( flux.fp ) )

tmax.fp <- rep( 0, 1000 )

coef.fp <- matrix( 0, 1000, 4 )

for ( j in 1:1000 ) {

  ly <- Yf.fp[ , j ]

  lt <- argvals.fp[ , j ]

  coef.fp[ j, ] <- lsfit( cbind( lt, lt^2, lt^3 ), ly )$coef

  tmax.fp[ j ] <- ( ( - coef.fp[ j, 3 ] ) - sqrt( coef.fp[ j, 3 ]^2 - 
    3 * coef.fp[ j, 2 ] * coef.fp[ j, 4 ] ) ) / ( 3 * coef.fp[ j, 4 ] )

  argvals.fp[ , j ] <- argvals.fp[ , j ] - tmax.fp[ j ]

}

ymax.fp <- coef.fp[ , 1 ] + coef.fp[ , 2 ] * tmax.fp + 
  coef.fp[ , 3 ] * tmax.fp^2 + coef.fp[ , 4 ] * tmax.fp^3

vertical.scale.fp <- matrix( 0, 50, 1000 )

for ( i in 1:50 ) {

  for ( j in 1:1000 ) {

    vertical.scale.fp[ i, j ] <- ymax.fp[ j ]

  }

}

Yf.fp <- Yf.fp - vertical.scale.fp

for ( i in 1:1000 ) {

  ly <- Yf.fp[ , i ]

  lt <- argvals.fp[ , i ]

  yt.reg <- lsfit( cbind( lt, lt^2 ), ly )

  plot( lt, ly, xlim = range( argvals.fp ),
    ylim = range( Yf.fp[ ! is.na( Yf.fp ) ] ) )

  lines( lt, cbind( 1, lt, lt^2 ) %*% yt.reg$coef, lty = 1 )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  plot( lt, yt.reg$residuals )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  abline( h = 0 )

}

#
#  Scatter plot of tmax vs. maximum dose
#


plot( tmax.fp, ymax.fp )

cor( tmax.fp, ymax.fp )


#
# Setting up the fd object.
#

fluxfd.spline.fp <- data2fd( Yf.fp, argvals.fp, splinebasis )

fluxfd.spline.fp <- smooth.fd( fluxfd.spline.fp, lambda = 1e-4 )

# Various plots.

par( ask = T )

for ( i in 1:1000 ) {

   plot.fd( fluxfd.spline.fp[ i ], ylim = c( log( 1e-12 ), 0 ) )

   points( argvals.fp[ , i ], Yf.fp[ , i ], matplt = T )

}

square.diff <- matrix ( 0, 50, 1000 )

for ( i in 1:1000 ) {

   argvals.vector <- argvals.fp[ ,i ]

   fit.val <- eval.fd( argvals.vector, fluxfd.spline.fp )

   for ( j in 1:50 ) {

     square.diff[ j, i ] <- ( fit.val[ j, i ] - Yf.fp[ j, i ] )^2

   }

}

#
# Plots of squared discrepancies between the data curves and the spline curves
#


par( ask = F, mfrow = c( 4, 2 ) )


for ( i in 1:1000 ) {

  plot( argvals.fp[ , i ], square.diff[ , i ] )

}

plot( mean.fd( fluxfd.spline.fp ) )

plot( std.fd( fluxfd.spline.fp ) )

#
# Principal Components Analysis
#
# Warning: Doesn't work with the default functions. We have to use a modified 
# version of pca.fd.ssc, which is located in David's home directory (under 
# Papers/Mendes)
#


pca.spline.fp <- pca.fd( fluxfd.spline.fp, nharm = 3 )

#
# Plotting  harmonics
#

temp.pca.spline.fp <-  pca.spline.fp[[1]]

finetime <- seq(-3,2,length=100)

spline.fd.mat.fp <- eval.fd(temp.pca.spline.fp,finetime)

plot(finetime, spline.fd.mat.fp[,1])
plot(finetime, spline.fd.mat.fp[,2])
plot(finetime, spline.fd.mat.fp[,3])

#
# Plotting perturbed values
#

plot.pca.fd( pca.spline.fp )

#
# Plotting the eigenvalues.
#

harm.eigval.fp <- pca.spline.fp$values

plot (1:14,log10(harm.eigval.fp[1:14]),type='b',xlab='Eigenvalue Number',
ylab='Log10 Eigenvalue')

abline ( lsfit(4:14,log10(harm.eigval.fp[4:14])),lty=2 )

#
# Plotting the scores
#

harm.scores.fp <- pca.spline.fp[[3]]

par ( mfrow=c(1,1),pty="s" )

# Indexed by run number

plot( harm.scores.fp [,1], harm.scores.fp [,2], type="n", xlab="Harm. I",
 ylab = "Harm. 2")

text ( harm.scores.fp [,1], harm.scores.fp [,2] )

# Not indexed at all


plot( harm.scores.fp [,1], harm.scores.fp [,2],xlab="Harm. I",
 ylab = "Harm. 2")

#
# Linear Modelling
#


# Reading model's input values.

# Each row of 'tinputs.fp' will contain the inputs values for the i-th run

tinputs.fp <- matrix( scan( "fp-i-det.d" ), 1000, 111, 
  byrow = t )[ , 2:10]
  
# Mean and S.D. of each input parameter

mean (tinputs.fp[,1])

sqrt(var(tinputs.fp[,1]))

mean (tinputs.fp[,2])

sqrt(var(tinputs.fp[,2]))

mean (tinputs.fp[,3])

sqrt(var(tinputs.fp[,3]))

mean (tinputs.fp[,4])

sqrt(var(tinputs.fp[,4]))

mean (tinputs.fp[,5])

sqrt(var(tinputs.fp[,5]))

mean (tinputs.fp[,6])

sqrt(var(tinputs.fp[,6]))

mean (tinputs.fp[,7])

sqrt(var(tinputs.fp[,7]))

mean (tinputs.fp[,8])

sqrt(var(tinputs.fp[,8]))

mean (tinputs.fp[,9])

sqrt(var(tinputs.fp[,9]))

# Backtransforming the log values

tinputs.fp[,2] <- log( tinputs.fp[,2] )
tinputs.fp[,3] <- log( tinputs.fp[,3] )

tinputs.fp[,9] <- log( tinputs.fp[,9] )

tinputs.fp <- tinputs.fp[,-6]

# Standardizing the dose curves

for (i in 1:15)
{
   coef.fp[i,] <- (coef.fp[i,] - mean (coef.fp[i,]))/ sqrt(var(coef.fp[i,]))
}

fd.fp <- create.fd( coef.fp, splinebasis )

reg.fp <- linmod.fd( tinputs.fp, fd.fp )

beta.fp <- reg.fp$reg

plot( beta.fp[1], 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.fp[2],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.fp[3],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.fp[4],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.fp[5],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.fp[6],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.fp[7],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.fp[8],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

plot( beta.fp[9],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )


plot( beta.fp, ylim = c( -0.6, 0.3 ), 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )



yhat.fp <- reg.fp$yhat

plot( yhat.fp, ylim = c( log( 1e-12 ), 0 ) )

















































#
#
# EIC scenario
#
#


dose.eic <- matrix( scan( "eic-i.d" ), 1000, 114, 
  byrow = T )[ , 65:114 ]

time.eic <- matrix( scan( "eic-i.d" ), 1000, 114, 
  byrow = T ) [ ,15:64 ]

dose.eic[ dose.eic < 1e-12 ] <- NA

for ( i in 1:1000 ) {
  count <- 0
  
  for ( j in 1:50 ) {
     if ( is.na( dose.eic [ i,j ]) == FALSE ) {
       count <- count +1
     }
  }
  
  if ( count<3 ) {
    cat ("Curve ", i, " doesn't have enough values!")
  }
}


argvals.eic <- log( t( time.eic ) )

Y.eic <- log( t( dose.eic ) )

tmax.eic <- rep( 0, 1000 )

coef.eic <- matrix( 0, 1000, 4 )

for ( j in 1:1000 ) {

  ly <- Y.eic[ , j ]

  lt <- argvals.eic[ , j ]

  coef.eic[ j, ] <- lsfit( cbind( lt, lt^2, lt^3 ), ly )$coef

  tmax.eic[ j ] <- ( ( - coef.eic[ j, 3 ] ) - sqrt( coef.eic[ j, 3 ]^2 - 
    3 * coef.eic[ j, 2 ] * coef.eic[ j, 4 ] ) ) / ( 3 * coef.eic[ j, 4 ] )

  argvals.eic[ , j ] <- argvals.eic[ , j ] - tmax.eic[ j ]

}

ymax.eic <- coef.eic[ , 1 ] + coef.eic[ , 2 ] * tmax.eic + 
  coef.eic[ , 3 ] * tmax.eic^2 + coef.eic[ , 4 ] * tmax.eic^3

vertical.scale.eic <- matrix( 0, 50, 1000 )

for ( i in 1:50 ) {

  for ( j in 1:1000 ) {

    vertical.scale.eic[ i, j ] <- ymax.eic[ j ]

  }

}

Y.eic <- Y.eic - vertical.scale.eic


# For this scenario, everything above this line is included in the workspace

graphics.off()

postscript("cubic-fit-small.eic.ps")


par( ask = F, mfrow = c( 4, 2 ) )

#
# Cubic fitting of the data to find the maximum of the curve.
#


for ( i in 1:1000 ) {

  ly <- Y.eic[ , i ]

  lt <- argvals.eic[ , i ]

  yt.reg <- lsfit( cbind( lt, lt^2 ), ly )

  if (i<5)
  {
  plot( lt, ly, xlim = range( argvals.eic ),
    ylim = range( Y.eic[ ! is.na( Y.eic ) ] ), xlab = "Time (yr)", ylab = "Dose (Sv/yr)" )

  lines( lt, cbind( 1, lt, lt^2 ) %*% yt.reg$coef, lty = 1 )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  plot( lt, yt.reg$residuals, xlab = "Time (yr)", ylab = "(Fitted - data value)^2" )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  abline( h = 0 )
  }

}

par( ask = F, mfrow = c( 1, 1 ) )

#
# Plotting all the curves
#

graphics.off()

postscript("all_reg-curves.eic.ps")

par( ask = F, mfrow = c( 1, 1 ) )

plot( argvals.eic[ , 1 ], Y.eic[ , 1 ], xlim = range( argvals.eic ),
    ylim = range( Y.eic[ ! is.na( Y.eic ) ] ), type = 'l', xlab = "Time (yr)", ylab = "Dose (Sv/yr)" )

for ( i in 2:1000 ) {

  lines( argvals.eic[ , i ], Y.eic[ , i ], lty = 1 )

}

#
#  Scatter plot of tmax vs. maximum dose
#

graphics.off()

postscript("tmax-maxdose.eic.ps")

plot( tmax.eic, ymax.eic, xlab = "Time (Yr)", ylab = "Dose (Sv/yr)"  )

#
# Splines
#
# Spline basis defined on the block dedicated top the Reference scenario


dosefd.spline.eic <- data2fd( Y.eic, argvals.eic, splinebasis )

dosefd.spline.eic <- smooth.fd( dosefd.spline.eic, lambda = 1e-4 )

# Plotting splines superimposed on data values


graphics.off()

postscript("splines.eic.ps")

par( ask = F, mfrow = c( 4, 2 ) )

for ( i in 1:8 ) {

   plot.fd( dosefd.spline.eic[ i ], ylim = c( log( 1e-12 ), 0 ), xlab = "Time (Yr)", ylab = "Dose (Sv/yr)" )

   points( argvals.eic[ , i ], Y.eic[ , i ], matplt = T )

}

square.diff <- matrix ( 0, 50, 1000 )

for ( i in 1:1000 ) {

   argvals.vector <- argvals.eic[ ,i ]

   fit.val <- eval.fd( argvals.vector, dosefd.spline.eic )

   for ( j in 1:50 ) {

     square.diff[ j, i ] <- ( fit.val[ j, i ] - Y.eic[ j, i ] )^2

   }

}

#
# Plots of squared discrepancies between the data curves and the spline curves
#

graphics.off()

postscript("splines-discrepancies.eic.ps")

par( ask = F, mfrow = c( 4, 2 ) )


for ( i in 1:8 ) {

  plot( argvals.eic[ , i ], square.diff[ , i ], xlab = "Time (Yr)", ylab = "(Fitted - data value)^2" )

}

graphics.off()

postscript("mean-sd.eic.ps")

par( ask = F, mfrow = c( 2, 1 ) )

plot( mean.fd( dosefd.spline.eic ), xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )" )

plot( std.fd( dosefd.spline.eic ), xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )" )


#
# Principal Components Analysis
#
# Warning: Doesn't work with the default functions. We have to use a modified 
# version of pca.fd.ssc, which is located in David's home directory (under 
# Papers/Mendes)
#


pca.spline.eic <- pca.fd( dosefd.spline.eic, nharm = 3 )


#
# Plotting harmonics
#

temp.pca.spline.eic <-  pca.spline.eic[[1]]

finetime <- seq(-3,2,length=100)

spline.fd.mat.eic <- eval.fd(temp.pca.spline.eic,finetime)

graphics.off()

postscript("pca123.eic.ps")

par( ask = F, mfrow = c( 3, 1 ) )

plot(finetime, spline.fd.mat.eic[,1], xlab = "log( Time (Yr) )", ylab = "Value of Principal Component Curve")

plot(finetime, spline.fd.mat.eic[,2], xlab = "log( Time (Yr) )", ylab = "Value of Principal Component Curve")

plot(finetime, spline.fd.mat.eic[,3], xlab = "log( Time (Yr) )", ylab = "Value of Principal Component Curve")


#
# Plotting perturbed mean
#
X11(colortype="pseudo.cube")

graphics.off()

postscript("pca-perturbed-mean123.eic.ps")

par( ask = F, mfrow = c( 3, 1 ) )

plot.pca.fd( pca.spline.eic, harm=1, xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )")

plot.pca.fd( pca.spline.eic, harm=2, xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )")

plot.pca.fd( pca.spline.eic, harm=3, xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )")

#
# Plotting the eigenvalues.
#

harm.eigval.eic <- pca.spline.eic$values

graphics.off()

postscript("pca-eigenvalues.eic.ps")

plot (1:14,log10(harm.eigval.eic[1:14]),type='b',xlab='Eigenvalue Number',ylab='Log10 Eigenvalue')

abline ( lsfit(4:14,log10(harm.eigval.eic[4:14])),lty=2 )

#
# Plotting the scores
#

graphics.off()

postscript("pca-scores.eic.ps")

harm.scores.eic <- pca.spline.eic[[3]]

par ( mfrow=c(1,1),pty="s" )

# Indexed by run number

plot( harm.scores.eic [,1], harm.scores.eic [,2], type="n", xlab="Harm. I", ylab = "Harm. 2")

text ( harm.scores.eic [,1], harm.scores.eic [,2] )


# Not indexed at all


plot( harm.scores.eic [,1], harm.scores.eic [,2],xlab="Harm. I",
 ylab = "Harm. 2")


#
# Linear Modelling
#


# Reading model's input values.

tinputs.eic <- matrix( scan( "eic-i.d" ), 1000, 114, 
  byrow = t )[ , 2:13]

# Mean and S.D. of each input parameter

mean (tinputs.eic[,1])

sqrt(var(tinputs.eic[,1]))

mean (tinputs.eic[,2])

sqrt(var(tinputs.eic[,2]))

mean (tinputs.eic[,3])

sqrt(var(tinputs.eic[,3]))

mean (tinputs.eic[,4])

sqrt(var(tinputs.eic[,4]))

mean (tinputs.eic[,5])

sqrt(var(tinputs.eic[,5]))

mean (tinputs.eic[,6])

sqrt(var(tinputs.eic[,6]))

mean (tinputs.eic[,7])

sqrt(var(tinputs.eic[,7]))

mean (tinputs.eic[,8])

sqrt(var(tinputs.eic[,8]))

mean (tinputs.eic[,9])

sqrt(var(tinputs.eic[,9]))

mean (tinputs.eic[,10])

sqrt(var(tinputs.eic[,10]))

mean (tinputs.eic[,11])

sqrt(var(tinputs.eic[,11]))

mean (tinputs.eic[,12])

sqrt(var(tinputs.eic[,12]))

# Backtransforming the log values

tinputs.eic[,2] <- log( tinputs.eic[,2] )
tinputs.eic[,3] <- log( tinputs.eic[,3] )
tinputs.eic[,6] <- log( tinputs.eic[,6] )
tinputs.eic[,9] <- log( tinputs.eic[,9] )


# Standardizing the input parameters
# Leads to pathological results
#for (i in 1:12)
#{
#   tinputs.eic[,i] <- (tinputs.eic[,i] - mean (tinputs.eic[,i]))/ sqrt(var(tinputs.eic[,i]))
#}

xfd.eic <- cbind( rep( 1, 1000 ), tinputs.eic)

coef.eic <- getcoef( dosefd.spline.eic )

# Standardizing the dose curves
# Leads to pathological results
#for (i in 1:15)
#{
#   coef.eic[i,] <- (coef.eic[i,] - mean (coef.eic[i,]))/ sqrt(var(coef.eic[i,]))
#}


fd.eic <- create.fd( coef.eic, splinebasis )

reg.eic <- linmod.fd( tinputs.eic, fd.eic )

beta.eic <- reg.eic$reg

graphics.off()

postscript("linreg-beta1.eic.ps")

plot( beta.eic[1], 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta2.eic.ps")

plot( beta.eic[2],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta3.eic.ps")

plot( beta.eic[3],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta4.eic.ps")

plot( beta.eic[4],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta5.eic.ps")

plot( beta.eic[5],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta6.eic.ps")

plot( beta.eic[6],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta7.eic.ps")

plot( beta.eic[7],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta8.eic.ps")

plot( beta.eic[8],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )
graphics.off()

postscript("linreg-beta9.eic.ps")

plot( beta.eic[9],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )
graphics.off()

postscript("linreg-beta10.eic.ps")

plot( beta.eic[10],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )
graphics.off()

postscript("linreg-beta11.eic.ps")

plot( beta.eic[11],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )
graphics.off()

postscript("linreg-beta12.eic.ps")

plot( beta.eic[12],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )


graphics.off()

postscript("linreg-allbetas.eic.ps")

plot( beta.eic, ylim = c( -0.5, 0.3 ), 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )



yhat.eic <- reg.eic$yhat

plot( yhat.eic, ylim = c( log( 1e-12 ), 0 ) )









#Figures for MPhil thesis

graphics.off()

postscript("linreg-beta1234.eic.ps")

par(title="Environmental Induced changes Scenario Scenario",mfrow = c( 2, 2 ))

plot( beta.eic[1],xlab ='log( time )', 
ylab = 'log( dose )',main="Containment time")

plot( beta.eic[2],xlab ='log( time )', 
ylab = 'log( dose )',main="Leaching rate")

plot( beta.eic[3],xlab ='log( time )', 
ylab = 'log( dose )',main="Water velocity, Layer 1")

plot( beta.eic[4],xlab ='log( time )', 
ylab = 'log( dose )',main="Layer 1 length")

graphics.off()

postscript("linreg-beta5678.eic.ps")

par(title="Environmental Induced changes Scenario Scenario",mfrow = c( 2, 2 ))

plot( beta.eic[5],xlab ='log( time )', 
ylab = 'log( dose )',main="Retention in layer 1")

plot( beta.eic[6],xlab ='log( time )', 
ylab = 'log( dose )',main="Water velocity in layer 2")

plot( beta.eic[7],xlab ='log( time )', 
ylab = 'log( dose )',main="Layer 2 length")

plot( beta.eic[8],xlab ='log( time )', 
ylab = 'log( dose )',main="Retention in layer 2")


graphics.off()

postscript("linreg-beta9101112.eic.ps")

par(title="Environmental Induced changes Scenario",mfrow = c( 2, 2 ))

plot( beta.eic[9],xlab ='log( time )', 
ylab = 'log( dose )',main="Water flow rate")

plot( beta.eic[10],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Slow Reversible adsorption, Forward reaction, layer 1" )

plot( beta.eic[11],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Slow Reversible adsorption, Forward reaction, layer 2"  )

plot( beta.eic[12],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Biodegradation layer 2"  )

graphics.off()























#
#
#   GA scenario.
#
#


dose.ga <- matrix( scan( "ga-i.d" ), 1000, 113, 
  byrow = T )[ , 64:113 ]

time.ga <- matrix( scan( "ga-i.d" ), 1000, 113, 
  byrow = T ) [ ,14:63 ]

dose.ga[ dose.ga < 1e-12 ] <- NA

for ( i in 1:1000 ) {
  count <- 0
  
  for ( j in 1:50 ) {
     if ( is.na( dose.ga [ i,j ]) == FALSE ) {
       count <- count +1
     }
  }
  
  if ( count<3 ) {
    cat ("Curve ", i, " doesn't have enough values!")
  }
}


argvals.ga <- log( t( time.ga ) )

Y.ga <- log( t( dose.ga ) )

tmax.ga <- rep( 0, 1000 )

coef.ga <- matrix( 0, 1000, 4 )

for ( j in 1:1000 ) {

  ly <- Y.ga[ , j ]

  lt <- argvals.ga[ , j ]

  coef.ga[ j, ] <- lsfit( cbind( lt, lt^2, lt^3 ), ly )$coef

  tmax.ga[ j ] <- ( ( - coef.ga[ j, 3 ] ) - sqrt( coef.ga[ j, 3 ]^2 - 
    3 * coef.ga[ j, 2 ] * coef.ga[ j, 4 ] ) ) / ( 3 * coef.ga[ j, 4 ] )

  argvals.ga[ , j ] <- argvals.ga[ , j ] - tmax.ga[ j ]

}

ymax.ga <- coef.ga[ , 1 ] + coef.ga[ , 2 ] * tmax.ga + 
  coef.ga[ , 3 ] * tmax.ga^2 + coef.ga[ , 4 ] * tmax.ga^3

vertical.scale.ga <- matrix( 0, 50, 1000 )

for ( i in 1:50 ) {

  for ( j in 1:1000 ) {

    vertical.scale.ga[ i, j ] <- ymax.ga[ j ]

  }

}

Y.ga <- Y.ga - vertical.scale.ga


# For this scenario, everything above this line is included in the workspace



par( ask = F, mfrow = c( 4, 2 ) )

#
# Cubic fitting of the data to find the maximum of the curve.
#

for ( i in 1:1000 ) {

  ly <- Y.ga[ , i ]

  lt <- argvals.ga[ , i ]

  yt.reg <- lsfit( cbind( lt, lt^2 ), ly )

  plot( lt, ly, xlim = range( argvals.ga ),
    ylim = range( Y.ga[ ! is.na( Y.ga ) ] ) )

  lines( lt, cbind( 1, lt, lt^2 ) %*% yt.reg$coef, lty = 1 )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  plot( lt, yt.reg$residuals )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  abline( h = 0 )

}

#
# Plotting all the curves
#

plot( argvals.ga[ , 1 ], Y.ga[ , 1 ], xlim = range( argvals.ga ),
    ylim = range( Y.ga[ ! is.na( Y.ga ) ] ), type = 'l' )

for ( i in 2:1000 ) {

  lines( argvals.ga[ , i ], Y.ga[ , i ], lty = 1 )

}

#
#  Scatter plot of tmax vs. maximum dose
#

graphics.off()

postscript("tmax-maxdose.ga.ps")

plot( tmax.ga, ymax.ga, xlab = "Time (Yr)", ylab = "Dose (Sv/yr)" )

#
# Splines
#
# Spline basis defined on the block dedicated top the Reference scenario


dosefd.spline.ga <- data2fd( Y.ga, argvals.ga, splinebasis )

dosefd.spline.ga <- smooth.fd( dosefd.spline.ga, lambda = 1e-4 )



#
# Principal Components Analysis
#
# Warning: Doesn't work with the default functions. We have to use a modified 
# version of pca.fd.ssc, which is located in David's home directory (under 
# Papers/Mendes)
#


pca.spline.ga <- pca.fd( dosefd.spline.ga, nharm = 3 )

#
# Plotting harmonics
#

temp.pca.spline.ga <-  pca.spline.ga[[1]]

finetime <- seq(-3,2,length=100)

spline.fd.mat.ga <- eval.fd(temp.pca.spline.ga,finetime)

graphics.off()

postscript("pca123.ga.ps")

par( ask = F, mfrow = c( 3, 1 ) )

plot(finetime, spline.fd.mat.ga[,1], xlab = "log( Time (Yr) )", ylab = "Value of Principal Component Curve")

plot(finetime, spline.fd.mat.ga[,2], xlab = "log( Time (Yr) )", ylab = "Value of Principal Component Curve")

plot(finetime, spline.fd.mat.ga[,3], xlab = "log( Time (Yr) )", ylab = "Value of Principal Component Curve")


#
# Plotting perturbed mean curves.
# 

X11(colortype="pseudo.cube")

graphics.off()

postscript("pca-perturbed-mean123.ga.ps")

par( ask = F, mfrow = c( 3, 1 ) )

plot.pca.fd( pca.spline.ga, harm=1, xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )")

plot.pca.fd( pca.spline.ga, harm=2, xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )")

plot.pca.fd( pca.spline.ga, harm=3, xlab = "log( Time (Yr) )", ylab = "log( Dose (Sv/yr) )")

#
# Plotting the eigenvalues.
#

harm.eigval.ga <- pca.spline.ga$values

graphics.off()

postscript("pca-eigenvalues.ga.ps")

plot (1:14,log10(harm.eigval.ga[1:14]),type='b',xlab='Eigenvalue Number',ylab='Log10 Eigenvalue')

abline ( lsfit(4:14,log10(harm.eigval.ga[4:14])),lty=2 )

#
# Plotting the scores
#

harm.scores.ga <- pca.spline.ga[[3]]

par ( mfrow=c(1,1),pty="s" )

# Indexed by run number

graphics.off()

postscript("pca-scores.ga.ps")

plot( harm.scores.ga [,1], harm.scores.ga [,2], type="n", xlab="Harm. I", ylab = "Harm. 2")

text ( harm.scores.ga [,1], harm.scores.ga [,2] )

# Not indexed at all


plot( harm.scores.ga [,1], harm.scores.ga [,2],xlab="Harm. I",
 ylab = "Harm. 2")


#
# Linear Modelling
#


# Reading model's input values.

tinputs.ga <- matrix( scan( "ga-i.d" ), 1000, 113, 
  byrow = t )[ , 2:12]

# Mean and S.D. of each input parameter

mean (tinputs.ga[,1])

sqrt(var(tinputs.ga[,1]))

mean (tinputs.ga[,2])

sqrt(var(tinputs.ga[,2]))

mean (tinputs.ga[,3])

sqrt(var(tinputs.ga[,3]))

mean (tinputs.ga[,4])

sqrt(var(tinputs.ga[,4]))

mean (tinputs.ga[,5])

sqrt(var(tinputs.ga[,5]))

mean (tinputs.ga[,6])

sqrt(var(tinputs.ga[,6]))

mean (tinputs.ga[,7])

sqrt(var(tinputs.ga[,7]))

mean (tinputs.ga[,8])

sqrt(var(tinputs.ga[,8]))

mean (tinputs.ga[,9])

sqrt(var(tinputs.ga[,9]))

mean (tinputs.ga[,10])

sqrt(var(tinputs.ga[,10]))

mean (tinputs.ga[,11])

sqrt(var(tinputs.ga[,11]))

# Backtransforming the log values

tinputs.ga[,2] <- log( tinputs.ga[,2] )
tinputs.ga[,3] <- log( tinputs.ga[,3] )
tinputs.ga[,6] <- log( tinputs.ga[,6] )
tinputs.ga[,9] <- log( tinputs.ga[,9] )


# Standardizing the input parameters
# Leads to pathological results
#for (i in 1:11)
#{
#   tinputs.ga[,i] <- (tinputs.ga[,i] - mean (tinputs.ga[,i]))/ sqrt(var(tinputs.ga[,i]))
#}

xfd.ga <- cbind( rep( 1, 1000 ), tinputs.ga)

coef.ga <- getcoef( dosefd.spline.ga )

# Standardizing the dose curves
# Leads to pathological results
#for (i in 1:15)
#{
#   coef.ga[i,] <- (coef.ga[i,] - mean (coef.ga[i,]))/ sqrt(var(coef.ga[i,]))
#}


fd.ga <- create.fd( coef.ga, splinebasis )

reg.ga <- linmod.fd( tinputs.ga, fd.ga )

beta.ga <- reg.ga$reg

graphics.off()

postscript("linreg-beta1.ga.ps")

plot( beta.ga[1], 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta2.ga.ps")

plot( beta.ga[2],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta3.ga.ps")

plot( beta.ga[3],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta4.ref.ps")

plot( beta.ga[4],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta5.ga.ps")

plot( beta.ga[5],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta6.ga.ps")

plot( beta.ga[6],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta7.ga.ps")

plot( beta.ga[7],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta8.ga.ps")

plot( beta.ga[8],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta9.ga.ps")

plot( beta.ga[9],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta10.ga.ps")

plot( beta.ga[10],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta11.ga.ps")

plot( beta.ga[11],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-allbetas.ga.ps")

plot( beta.ga, ylim = c( -0.7, 0.2 ), 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

yhat.ga <- reg.ga$yhat

plot( yhat.ga, ylim = c( log( 1e-12 ), 0 ) )






#Figures for MPhil thesis

graphics.off()

postscript("linreg-beta1234.ga.ps")

par(title="Glacial Advance Scenario Scenario",mfrow = c( 2, 2 ))

plot( beta.ga[1],xlab ='log( time )', 
ylab = 'log( dose )',main="Containment time")

plot( beta.ga[2],xlab ='log( time )', 
ylab = 'log( dose )',main="Leaching rate")

plot( beta.ga[3],xlab ='log( time )', 
ylab = 'log( dose )',main="Water velocity, Layer 1")

plot( beta.ga[4],xlab ='log( time )', 
ylab = 'log( dose )',main="Layer 1 length")

graphics.off()

postscript("linreg-beta5678.ga.ps")

par(title="Glacial Advance Scenario",mfrow = c( 2, 2 ))

plot( beta.ga[5],xlab ='log( time )', 
ylab = 'log( dose )',main="Retention in layer 1")

plot( beta.ga[6],xlab ='log( time )', 
ylab = 'log( dose )',main="Water velocity in layer 2")

plot( beta.ga[7],xlab ='log( time )', 
ylab = 'log( dose )',main="Layer 2 length")

plot( beta.ga[8],xlab ='log( time )', 
ylab = 'log( dose )',main="Retention in layer 2")


graphics.off()

postscript("linreg-beta9101112.ga.ps")

par(title="Glacial Advance Scenario",mfrow = c( 2, 2 ))

plot( beta.ga[9],xlab ='log( time )', 
ylab = 'log( dose )',main="Water flow rate")

plot( beta.ga[10],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Slow Reversible adsorption, Forward reaction, layer 1" )

plot( beta.ga[11],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Slow Reversible adsorption, Forward reaction, layer 2"  )

graphics.off()

























#
#
# HDE scenario
#
#


dose.hde <- matrix( scan( "hde-i.d" ), 1000, 116, 
  byrow = T )[ , 67:116 ]

time.hde <- matrix( scan( "hde-i.d" ), 1000, 116, 
  byrow = T ) [ ,17:66 ]

dose.hde[ dose.hde < 1e-12 ] <- NA

dose.hde <- dose.hde[-10,]
time.hde <- time.hde[-10,]

dose.hde <- dose.hde[-822,]
time.hde <- time.hde[-822,]

for ( i in 1:998 ) {
  count <- 0
  
  for ( j in 1:50 ) {
     if ( is.na( dose.hde [ i,j ]) == FALSE ) {
       count <- count +1
     }
  }
  
  if ( count<3 ) {
    cat ("Curve ", i, " doesn't have enough values!")
  }
}

argvals.hde <- log( t( time.hde ) )

Y.hde <- log( t( dose.hde ) )

tmax.hde <- rep( 0, 998 )

coef.hde <- matrix( 0, 998, 4 )

for ( j in 1:998 ) {

  ly <- Y.hde[ , j ]

  lt <- argvals.hde[ , j ]

  coef.hde[ j, ] <- lsfit( cbind( lt, lt^2, lt^3 ), ly )$coef

  tmax.hde[ j ] <- ( ( - coef.hde[ j, 3 ] ) - sqrt( coef.hde[ j, 3 ]^2 - 
    3 * coef.hde[ j, 2 ] * coef.hde[ j, 4 ] ) ) / ( 3 * coef.hde[ j, 4 ] )

  argvals.hde[ , j ] <- argvals.hde[ , j ] - tmax.hde[ j ]
  cat (" Curve", j, " complete!\n")

}



ymax.hde <- coef.hde[ , 1 ] + coef.hde[ , 2 ] * tmax.hde + 
  coef.hde[ , 3 ] * tmax.hde^2 + coef.hde[ , 4 ] * tmax.hde^3

vertical.scale.hde <- matrix( 0, 50, 998 )

for ( i in 1:50 ) {

  for ( j in 1:998 ) {

    vertical.scale.hde[ i, j ] <- ymax.hde[ j ]

  }

}

Y.hde <- Y.hde - vertical.scale.hde


# For this scenario, everything above this line is included in the workspace



par( ask = F, mfrow = c( 4, 2 ) )

#
# Cubic fitting of the data to find the maximum of the curve.
#

for ( i in 1:998 ) {

  ly <- Y.hde[ , i ]

  lt <- argvals.hde[ , i ]

  yt.reg <- lsfit( cbind( lt, lt^2 ), ly )

  plot( lt, ly, xlim = range( argvals.hde ),
    ylim = range( Y.hde[ ! is.na( Y.hde ) ] ) )

  lines( lt, cbind( 1, lt, lt^2 ) %*% yt.reg$coef, lty = 1 )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  plot( lt, yt.reg$residuals )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  abline( h = 0 )

}


#
# Plotting all the curves
#


plot( argvals.hde[ , 1 ], Y.hde[ , 1 ], xlim = range( argvals.hde ),
    ylim = range( Y.hde[ ! is.na( Y.hde ) ] ), type = 'l' )

for ( i in 2:998 ) {

  lines( argvals.hde[ , i ], Y.hde[ , i ], lty = 1 )

}

#
#  Scatter plot of tmax vs. maximum dose
#

graphics.off()

postscript("tmax-maxdose.hde.ps")

plot( tmax.hde, ymax.hde, xlab = "Time (Yr)", ylab = "Dose (Sv/yr)" )


#
# Splines
#
# Spline basis defined on the block dedicated top the Reference scenario


dosefd.spline.hde <- data2fd( Y.hde, argvals.hde, splinebasis )

dosefd.spline.hde <- smooth.fd( dosefd.spline.hde, lambda = 1e-4 )



#
# Principal Components Analysis
#
# Warning: Doesn't work with the default functions. We have to use a modified 
# version of pca.fd.ssc, which is located in David's home directory (under 
# Papers/Mendes)
#


pca.spline.hde <- pca.fd( dosefd.spline.hde, nharm = 3 )


#
# Plotting harmonics
#

temp.pca.spline.hde <-  pca.spline.hde[[1]]

finetime <- seq(-3,2,length=100)

spline.fd.mat.hde <- eval.fd(temp.pca.spline.hde,finetime)

graphics.off()

postscript("pca1.hde.ps")

plot(finetime, spline.fd.mat.hde[,1], xlab = "Time (Yr)", ylab = "Value of Principal Component Curve")

graphics.off()

postscript("pca2.hde.ps")

plot(finetime, spline.fd.mat.hde[,2], xlab = "Time (Yr)", ylab = "Value of Principal Component Curve")

graphics.off()

postscript("pca3.hde.ps")

plot(finetime, spline.fd.mat.hde[,3], xlab = "Time (Yr)", ylab = "Value of Principal Component Curve")


#
# Plotting perturbed mean
#

X11(colortype="pseudo.cube")

graphics.off()

postscript("pca-perturbed-mean1.hde.ps")

plot.pca.fd( pca.spline.hde, harm=1, xlab = "Time (Yr)", ylab = "Dose (Sv/yr)")

graphics.off()

postscript("pca-perturbed-mean2.hde.ps")

plot.pca.fd( pca.spline.hde, harm=2, xlab = "Time (Yr)", ylab = "Dose (Sv/yr)")

graphics.off()

postscript("pca-perturbed-mean3.hde.ps")

plot.pca.fd( pca.spline.hde, harm=3, xlab = "Time (Yr)", ylab = "Dose (Sv/yr)")

#
# Plotting the eigenvalues.
#

harm.eigval.hde <- pca.spline.hde$values

graphics.off()

postscript("pca-eigenvalues.hde.ps")

plot (1:14,log10(harm.eigval.hde[1:14]),type='b',xlab='Eigenvalue Number',ylab='Log10 Eigenvalue')

abline ( lsfit(4:14,log10(harm.eigval.hde[4:14])),lty=2 )

#
# Plotting the scores
#

graphics.off()

postscript("pca-scores.hde.ps")

harm.scores.hde <- pca.spline.hde[[3]]

par ( mfrow=c(1,1),pty="s" )

# Indexed by run number

plot( harm.scores.hde [,1], harm.scores.hde [,2], type="n", xlab="Harm. I", ylab = "Harm. 2")

text ( harm.scores.hde [,1], harm.scores.hde [,2] )


# Not indexed at all

plot( harm.scores.hde [,1], harm.scores.hde [,2],xlab="Harm. I",
 ylab = "Harm. 2")


#
# Linear Modelling
#


# Reading model's input values.

tinputs.hde <- matrix( scan( "hde-i.d" ), 1000, 116, 
  byrow = t )[ , 2:15]

# taking away inputs that originated bad curves

tinputs.hde <- tinputs.hde[-10,]
tinputs.hde <- tinputs.hde[-822,]

# Mean and S.D. of each input parameter

mean (tinputs.hde[,1])

sqrt(var(tinputs.hde[,1]))

mean (tinputs.hde[,2])

sqrt(var(tinputs.hde[,2]))

mean (tinputs.hde[,3])

sqrt(var(tinputs.hde[,3]))

mean (tinputs.hde[,4])

sqrt(var(tinputs.hde[,4]))

mean (tinputs.hde[,5])

sqrt(var(tinputs.hde[,5]))

mean (tinputs.hde[,6])

sqrt(var(tinputs.hde[,6]))

mean (tinputs.hde[,7])

sqrt(var(tinputs.hde[,7]))

mean (tinputs.hde[,8])

sqrt(var(tinputs.hde[,8]))

mean (tinputs.hde[,9])

sqrt(var(tinputs.hde[,9]))

mean (tinputs.hde[,10])

sqrt(var(tinputs.hde[,10]))

mean (tinputs.hde[,11])

sqrt(var(tinputs.hde[,11]))

mean (tinputs.hde[,12])

sqrt(var(tinputs.hde[,12]))

mean (tinputs.hde[,13])

sqrt(var(tinputs.hde[,13]))

mean (tinputs.hde[,14])

sqrt(var(tinputs.hde[,14]))

# Backtransforming the log values

tinputs.hde[,2] <- log( tinputs.hde[,2] )
tinputs.hde[,3] <- log( tinputs.hde[,3] )
tinputs.hde[,6] <- log( tinputs.hde[,6] )
tinputs.hde[,9] <- log( tinputs.hde[,9] )


# Standardizing the input parameters
# Leads to pathological results
#for (i in 1:14)
#{
#   tinputs.hde[,i] <- (tinputs.hde[,i] - mean (tinputs.hde[,i]))/ sqrt(var(tinputs.hde[,i]))
#}

xfd.hde <- cbind( rep( 1, 998 ), tinputs.hde)

coef.hde <- getcoef( dosefd.spline.hde )

# Standardizing the dose curves
# Leads to pathological results
#for (i in 1:15)
#{
#   coef.hde[i,] <- (coef.hde[i,] - mean (coef.hde[i,]))/ sqrt(var(coef.hde[i,]))
#}

fd.hde <- create.fd( coef.hde, splinebasis )

reg.hde <- linmod.fd( tinputs.hde, fd.hde )

beta.hde <- reg.hde$reg

graphics.off()

postscript("linreg-beta1.hde.ps")

plot( beta.hde[1], 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta2.hde.ps")

plot( beta.hde[2],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta3.hde.ps")

plot( beta.hde[3],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta4.hde.ps")

plot( beta.hde[4],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta5.hde.ps")

plot( beta.hde[5],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta6.hde.ps")

plot( beta.hde[6],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta7.hde.ps")

plot( beta.hde[7],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta8.hde.ps")

plot( beta.hde[8],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta9.hde.ps")

plot( beta.hde[9],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta10.hde.ps")

plot( beta.hde[10],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta11.hde.ps")

plot( beta.hde[11],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta12.hde.ps")

plot( beta.hde[12],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta13.hde.ps")

plot( beta.hde[13],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta14.hde.ps")

plot( beta.hde[14],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-allbetas.hde.ps")

plot( beta.hde, ylim = c( -0.5, 0.2 ), 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

yhat.hde <- reg.hde$yhat

plot( yhat.hde, ylim = c( log( 1e-12 ), 0 ) )






#Figures for MPhil thesis

graphics.off()

postscript("linreg-beta1234.hde.ps")

par(title="Human Disposal Errors Scenario",mfrow = c( 2, 2 ))

plot( beta.hde[1],xlab ='log( time )', 
ylab = 'log( dose )',main="Containment time")

plot( beta.hde[2],xlab ='log( time )', 
ylab = 'log( dose )',main="Leaching rate")

plot( beta.hde[3],xlab ='log( time )', 
ylab = 'log( dose )',main="Water velocity, Layer 1")

plot( beta.hde[4],xlab ='log( time )', 
ylab = 'log( dose )',main="Layer 1 length")

graphics.off()

postscript("linreg-beta5678.hde.ps")

par(title="Human Disposal Errors Scenario",mfrow = c( 2, 2 ))

plot( beta.hde[5],xlab ='log( time )', 
ylab = 'log( dose )',main="Retention in layer 1")

plot( beta.hde[6],xlab ='log( time )', 
ylab = 'log( dose )',main="Water velocity in layer 2")

plot( beta.hde[7],xlab ='log( time )', 
ylab = 'log( dose )',main="Layer 2 length")

plot( beta.hde[8],xlab ='log( time )', 
ylab = 'log( dose )',main="Retention in layer 2")


graphics.off()

postscript("linreg-beta9101112.hde.ps")

par(title="Human Disposal Errors Scenario",mfrow = c( 2, 2 ))

plot( beta.hde[9],xlab ='log( time )', 
ylab = 'log( dose )',main="Water flow rate")

plot( beta.hde[10],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Slow Reversible adsorption, Forward reaction, layer 1" )

plot( beta.hde[11],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Slow Reversible adsorption, Backward reaction, layer 1"  )

plot( beta.hde[12],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Slow Reversible adsorption, Forward reaction, layer 2" )


graphics.off()

postscript("linreg-beta1314.hde.ps")

par(title="Human Disposal Errors Scenario",mfrow = c( 2, 1 ))

plot( beta.hde[13],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Slow Reversible adsorption, Backward reaction, layer 2"  )

plot( beta.hde[14],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Biodegradation layer 2"  )

graphics.off()






















#
#
#  AG scenario
#
#


dose.ag <- matrix( scan( "ag-i.d" ), 1000, 117, 
  byrow = T )[ , 68:117 ]

time.ag <- matrix( scan( "ag-i.d" ), 1000, 117, 
  byrow = T ) [ ,18:67 ]

dose.ag[ dose.ag < 1e-12 ] <- NA

for ( i in 1:1000 ) {
  count <- 0
  
  for ( j in 1:50 ) {
     if ( is.na( dose.ag [ i,j ]) == FALSE ) {
       count <- count +1
     }
  }
  
  if ( count<3 ) {
    cat ("Curve ", i, " doesn't have enough values!")
  }
}


argvals.ag <- log( t( time.ag ) )

Y.ag <- log( t( dose.ag ) )

tmax.ag <- rep( 0, 1000 )

coef.ag <- matrix( 0, 1000, 4 )

for ( j in 1:1000 ) {

  ly <- Y.ag[ , j ]

  lt <- argvals.ag[ , j ]

  coef.ag[ j, ] <- lsfit( cbind( lt, lt^2, lt^3 ), ly )$coef

  tmax.ag[ j ] <- ( ( - coef.ag[ j, 3 ] ) - sqrt( coef.ag[ j, 3 ]^2 - 
    3 * coef.ag[ j, 2 ] * coef.ag[ j, 4 ] ) ) / ( 3 * coef.ag[ j, 4 ] )

  argvals.ag[ , j ] <- argvals.ag[ , j ] - tmax.ag[ j ]

}

ymax.ag <- coef.ag[ , 1 ] + coef.ag[ , 2 ] * tmax.ag + 
  coef.ag[ , 3 ] * tmax.ag^2 + coef.ag[ , 4 ] * tmax.ag^3

vertical.scale.ag <- matrix( 0, 50, 1000 )

for ( i in 1:50 ) {

  for ( j in 1:1000 ) {

    vertical.scale.ag[ i, j ] <- ymax.ag[ j ]

  }

}

Y.ag <- Y.ag - vertical.scale.ag



# For this scenario, everything above this line is included in the workspace




par( ask = F, mfrow = c( 4, 2 ) )

#
# Cubic fitting of the data to find the maximum of the curve.
#

for ( i in 1:1000 ) {

  ly <- Y.ag[ , i ]

  lt <- argvals.ag[ , i ]

  yt.reg <- lsfit( cbind( lt, lt^2 ), ly )

  plot( lt, ly, xlim = range( argvals.ag ),
    ylim = range( Y.ag[ ! is.na( Y.ag ) ] ) )

  lines( lt, cbind( 1, lt, lt^2 ) %*% yt.reg$coef, lty = 1 )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  plot( lt, yt.reg$residuals )

  abline( v = - yt.reg$coef[ 2 ] / ( 2 * yt.reg$coef[ 3 ] ) )

  abline( h = 0 )

}

#
# Plotting all the curves
#


plot( argvals.ag[ , 1 ], Y.ag[ , 1 ], xlim = range( argvals.ag ),
    ylim = range( Y.ag[ ! is.na( Y.ag ) ] ), type = 'l' )

for ( i in 2:1000 ) {

  lines( argvals.ag[ , i ], Y.ag[ , i ], lty = 1 )

}

#
#  Scatter plot of tmax vs. maximum dose
#

graphics.off()

postscript("tmax-maxdose.ag.ps")

plot( tmax.ag, ymax.ag, xlab = "Time (Yr)", ylab = "Dose (Sv/yr)" )


#
# Splines
#
# Spline basis defined on the block dedicated top the Reference scenario


dosefd.spline.ag <- data2fd( Y.ag, argvals.ag, splinebasis )

dosefd.spline.ag <- smooth.fd( dosefd.spline.ag, lambda = 1e-4 )



#
# Principal Components Analysis
#
# Warning: Doesn't work with the default functions. We have to use a modified 
# version of pca.fd.ssc, which is located in David's home directory (under 
# Papers/Mendes)
#


pca.spline.ag <- pca.fd( dosefd.spline.ag, nharm = 3 )


#
# Plotting harmonics
#


temp.pca.spline.ag <-  pca.spline.ag[[1]]

finetime <- seq(-3,2,length=100)

spline.fd.mat.ag <- eval.fd(temp.pca.spline.ag,finetime)

graphics.off()

postscript("pca1.ag.ps")

plot(finetime, spline.fd.mat.ag[,1], xlab = "Time (Yr)", ylab = "Value of Principal Component Curve")

graphics.off()

postscript("pca2.ag.ps")

plot(finetime, spline.fd.mat.ag[,2], xlab = "Time (Yr)", ylab = "Value of Principal Component Curve")

graphics.off()

postscript("pca3.ag.ps")

plot(finetime, spline.fd.mat.ag[,3], xlab = "Time (Yr)", ylab = "Value of Principal Component Curve")


#
# Plotting perturbed mean
#

graphics.off()

postscript("pca-perturbed-mean1.ag.ps")

plot.pca.fd( pca.spline.ag, harm=1, xlab = "Time (Yr)", ylab = "Dose (Sv/yr)" )

graphics.off()

postscript("pca-perturbed-mean2.ag.ps")

plot.pca.fd( pca.spline.ag, harm=2, xlab = "Time (Yr)", ylab = "Dose (Sv/yr)" )

graphics.off()

postscript("pca-perturbed-mean3.ag.ps")

plot.pca.fd( pca.spline.ag, harm=3, xlab = "Time (Yr)", ylab = "Dose (Sv/yr)" )

#
# Plotting the eigenvalues.
#

harm.eigval.ag <- pca.spline.ag$values

graphics.off()

postscript("pca-eigenvalues.ag.ps")

plot (1:14,log10(harm.eigval.ag[1:14]),type='b',xlab='Eigenvalue Number',ylab='Log10 Eigenvalue')

abline ( lsfit(4:14,log10(harm.eigval.ag[4:14])),lty=2 )

#
# Plotting the scores
#

harm.scores.ag <- pca.spline.ag[[3]]

par ( mfrow=c(1,1),pty="s" )

# Indexed by run number

plot( harm.scores.ag [,1], harm.scores.ag [,2], type="n", xlab="Harm. I", ylab = "Harm. 2")

text ( harm.scores.ag [,1], harm.scores.ag [,2] )

# Not indexed at all

plot( harm.scores.ag [,1], harm.scores.ag [,2],xlab="Harm. I",
 ylab = "Harm. 2")
 
 
#
# Linear Modelling
#


# Reading model's input values.

tinputs.ag <- matrix( scan( "ag-i.d" ), 1000, 117, 
  byrow = t )[ , 2:16]

# Mean and S.D. of each input parameter

mean (tinputs.ag[,1])

sqrt(var(tinputs.ag[,1]))

mean (tinputs.ag[,2])

sqrt(var(tinputs.ag[,2]))

mean (tinputs.ag[,3])

sqrt(var(tinputs.ag[,3]))

mean (tinputs.ag[,4])

sqrt(var(tinputs.ag[,4]))

mean (tinputs.ag[,5])

sqrt(var(tinputs.ag[,5]))

mean (tinputs.ag[,6])

sqrt(var(tinputs.ag[,6]))

mean (tinputs.ag[,7])

sqrt(var(tinputs.ag[,7]))

mean (tinputs.ag[,8])

sqrt(var(tinputs.ag[,8]))

mean (tinputs.ag[,9])

sqrt(var(tinputs.ag[,9]))

mean (tinputs.ag[,10])

sqrt(var(tinputs.ag[,10]))

mean (tinputs.ag[,11])

sqrt(var(tinputs.ag[,11]))

mean (tinputs.ag[,12])

sqrt(var(tinputs.ag[,12]))

mean (tinputs.ag[,13])

sqrt(var(tinputs.ag[,13]))

mean (tinputs.ag[,14])

sqrt(var(tinputs.ag[,14]))

mean (tinputs.ag[,15])

sqrt(var(tinputs.ag[,15]))



# Backtransforming the log values

tinputs.ag[,2] <- log( tinputs.ag[,2] )
tinputs.ag[,3] <- log( tinputs.ag[,3] )
tinputs.ag[,6] <- log( tinputs.ag[,6] )
tinputs.ag[,9] <- log( tinputs.ag[,9] )
tinputs.ag[,12] <- log( tinputs.ag[,12] )


# Standardizing the input parameters
# Leads to pathological results
#for (i in 1:15)
#{
#   tinputs.ag[,i] <- (tinputs.ag[,i] - mean (tinputs.ag[,i]))/ sqrt(var(tinputs.ag[,i]))
#}

xfd.ag <- cbind( rep( 1, 1000 ), tinputs.ag)

coef.ag <- getcoef( dosefd.spline.ag )

# Standardizing the dose curves
# Leads to pathological results
#for (i in 1:15)
#{
#   coef.ag[i,] <- (coef.ag[i,] - mean (coef.ag[i,]))/ sqrt(var(coef.ag[i,]))
#}

reg.ag <- linmod.fd( tinputs.ag, dosefd.spline.ag,ylambda=10 )


#fd.ag <- create.fd( coef.ag, splinebasis )

#reg.ag <- linmod.fd( tinputs.ag, fd.ag )

beta.ag <- reg.ag$reg

graphics.off()

postscript("linreg-beta1.ag.ps")

plot( beta.ag[1], 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta2 .ag.ps")

plot( beta.ag[2],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta3.ag.ps")

plot( beta.ag[3],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta4.ag.ps")

plot( beta.ag[4],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta5.ag.ps")

plot( beta.ag[5],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta6.ag.ps")

plot( beta.ag[6],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta7.ag.ps")

plot( beta.ag[7],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta8.ag.ps")

plot( beta.ag[8],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta9.ag.ps")

plot( beta.ag[9],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta10.ag.ps")

plot( beta.ag[10],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta11.ag.ps")

plot( beta.ag[11],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta12.ag.ps")

plot( beta.ag[12],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta13.ag.ps")

plot( beta.ag[13],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta14.ag.ps")

plot( beta.ag[14],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-beta15.ag.ps")

plot( beta.ag[15],  
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

graphics.off()

postscript("linreg-allbetas.ag.ps")

plot( beta.ag, ylim = c( -0.5, 0.2 ), 
  xlab = 'Recentered log( time )', ylab = 'Recentered log( dose )' )

yhat.ag <- reg.ag$yhat

plot( yhat.ag, ylim = c( -1, 1 ) )




# Plots for MPhil


graphics.off()

postscript("linreg-beta1234.ag.ps")

par(title="Additional Geosphere Scenario",mfrow = c( 2, 2 ))

plot( beta.ag[1],xlab ='log( time )', 
ylab = 'log( dose )',main="Containment time")

plot( beta.ag[2],xlab ='log( time )', 
ylab = 'log( dose )',main="Leaching rate")

plot( beta.ag[3],xlab ='log( time )', 
ylab = 'log( dose )',main="Water velocity, Layer 1")

plot( beta.ag[4],xlab ='log( time )', 
ylab = 'log( dose )',main="Layer 1 length")

graphics.off()

postscript("linreg-beta5678.ag.ps")

par(title="Additional Geosphere Scenario",mfrow = c( 2, 2 ))

plot( beta.ag[5],xlab ='log( time )', 
ylab = 'log( dose )',main="Retention in layer 1")

plot( beta.ag[6],xlab ='log( time )', 
ylab = 'log( dose )',main="Water velocity in layer 2")

plot( beta.ag[7],xlab ='log( time )', 
ylab = 'log( dose )',main="Layer 2 length")

plot( beta.ag[8],xlab ='log( time )', 
ylab = 'log( dose )',main="Retention in layer 2")


graphics.off()

postscript("linreg-beta9101112.ag.ps")

par(title="Additional Geosphere Scenario",mfrow = c( 2, 2 ))

plot( beta.ag[9],xlab ='log( time )', 
ylab = 'log( dose )',main="Water velocity in layer 3")

plot( beta.ag[10],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Layer 3 length" )

plot( beta.ag[11],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Retention in layer 3"  )

plot( beta.ag[12],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Water flow rate" )


graphics.off()

postscript("linreg-beta1314.ag.ps")

par(title="Human Disposal Errors Scenario",mfrow = c( 2, 1 ))

plot( beta.ag[13],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Slow Reversible adsorption, Forward reaction, layer 2"  )

plot( beta.ag[14],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Slow Reversible adsorption, Backward reaction, layer 2"  )


plot( beta.ag[15],  
  xlab = 'log( time )', 
  ylab = 'log( dose )', main="Biodegradation layer 3"  )

graphics.off()














######
######

All Scenarios together

######
######

coef.ref <- getcoef( dosefd.spline.ref )

coef.fp <- getcoef( dosefd.spline.fp )

coef.eic <- getcoef( dosefd.spline.eic )

coef.ga <- getcoef( dosefd.spline.ga )

coef.hde <- getcoef( dosefd.spline.hde )

coef.ag <- getcoef( dosefd.spline.ag )

coef.merge <- cbind( coef.ref, coef.fp, coef.eic, coef.ga, coef.hde, 
  coef.ag )

mergefd <- create.fd( coef.merge, splinebasis )

# PCA

pca.spline <- pca.fd( mergefd, nharm = 3 )

plot.pca.fd( pca.spline )

# ANOVA


xfd <- cbind( 
  rep( 1, 5998 ),
  c( rep( 1, 1000 ), rep( 0, 4998 ) ),   
  c( rep( 0, 1000 ), rep( 1, 1000 ), rep( 0, 3998 ) ),
  c( rep( 0, 2000 ), rep( 1, 1000 ), rep( 0, 2998 ) ),
  c( rep( 0, 3000 ), rep( 1, 1000 ), rep( 0, 1998 ) ),
  c( rep( 0, 4000 ), rep( 1, 998 ), rep( 0, 1000 ) ),
  c( rep( 0, 4998 ), rep( 1, 1000 ) ) 
)


linmod.str <- linmod.fd( xfd, mergefd,zmatrnk=6)

regfd <- linmod.str$reg

graphics.off()

postscript("anova-all.sce.ps")

plot( regfd, ylim = c( -20, 0.5 ), xlab = 'log( time )',
  ylab = 'log( dose )' )

graphics.off()

postscript("anova-each.sce.ps")

par( ask = F, mfrow = c( 3, 2 ) )

plot( regfd[1], ylim = c( -20, 0.5 ), xlab = 'Recentered log( time )',
  ylab = 'Recentered log( dose )' )
plot( regfd[2], ylim = c( -20, 0.5 ), xlab = 'Recentered log( time )',
  ylab = 'Recentered log( dose )' )
plot( regfd[3], ylim = c( -20, 0.5 ), xlab = 'Recentered log( time )',
  ylab = 'Recentered log( dose )' )
plot( regfd[4], ylim = c( -20, 0.5 ), xlab = 'Recentered log( time )',
  ylab = 'Recentered log( dose )' )
plot( regfd[5], ylim = c( -20, 0.5 ), xlab = 'Recentered log( time )',
  ylab = 'Recentered log( dose )' )
plot( regfd[6], ylim = c( -20, 0.5 ), xlab = 'Recentered log( time )',
  ylab = 'Recentered log( dose )' )
plot( regfd[7], ylim = c( -20, 0.5 ), xlab = 'Recentered log( time )',
  ylab = 'Recentered log( dose )' )

text( -1.8, 1.4, "HDE" )

text( -1.4, 1.4, "GA" )

text( -1.4, -1, "EIC" )

text( -0.8, -1, "AG" )

text( -0.5, -1, "FP" )

text( -0.2, -1, "Ref" )


yhatfd <- linmod.str$yhat

plot( yhatfd, ylim = c( log( 1e-12 ), 0 ) )

#
# Calculation of R^2
#

mat.fitted <- cbind(yhatfd[[1]][,1:1000],yhatfd[[1]][,1001:2000],
yhatfd[[1]][,2001:3000],yhatfd[[1]][,3001:4000],yhatfd[[1]][,4001:4998],
yhatfd[[1]][,4999:5998])

mat.data <- cbind(mergefd[[1]][,1:1000],mergefd[[1]][,1001:2000],
mergefd[[1]][,2001:3000],mergefd[[1]][,3001:4000],mergefd[[1]][,4001:4998],
mergefd[[1]][,4999:5998])

#
# Mean curve
#

mat.mean <- rep(mean(mergefd)[[1]],5998)
dim(mat.mean) <- c(15,5998)

# doesn't work because they're lists: sse <- (mergefd - xfd * mat)^2

se <- (mat.data - mat.fitted)^2

sse <- 0
for (i in 1:15)
{
  for (j in 1:5998)
  {
    sse[i] <- sse+se[i,j]
  }
}

sy <- (mat.data - mat.mean)^2

ssy <- 0
for (i in 1:15)
{
  for (j in 1:5998)
  {
    ssy[i] <- ssy+sy[i,j]
  }
}

r.square <- (ssy-sse)/ssy

# Playing with vecotrised calculations
> mydata
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> mydata[1,1:2]
[1] 1 3
> sum(mydata[1,1:2])
[1] 4
> sum(mydata[1:2,1])
[1] 3
> mydata[1:2,1]
[1] 1 2
> mydata[1,]
[1] 1 3
> mydata[1,1]
[1] 1
> mydata[2,1]
[1] 2
> 
> a <- cbind(c(1,2),c(3,4))
> b <- cbind(c(10,20),c(30,40))
> a-b
     [,1] [,2]
[1,]   -9  -27
[2,]  -18  -36
> a
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> b
     [,1] [,2]
[1,]   10   30
[2,]   20   40
> 
> mat.mean[,1]
 [1] -64.7059162 -61.3464179 -53.5219833 -43.0161463 -31.8364876 -20.8336346
 [7]  -9.7969089  -2.1555230   0.5859611  -0.7772630  -6.5810807 -18.1437541
[13] -31.1330248 -40.5627165 -44.7312185
> mat.data[,1]
 [1] -30.2560209 -28.5921723 -25.2938371 -20.3107375 -15.3423684 -10.4190667
 [7]  -5.2043255  -1.3513385   0.4076478  -0.3577767  -3.6701600  -9.7445700
[13] -18.9978620 -24.6820311 -27.5606381
